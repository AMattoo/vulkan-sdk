<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Vulkan SDK for Android 1.1.1: Introduction to Compute Shaders in Vulkan</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vulkan SDK for Android 1.1.1
<span id="malidevcenter"><a href="http://malideveloper.arm.com">Mali Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('basic_compute.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction to Compute Shaders in Vulkan </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Shows you how to use compute shaders in Vulkan.</p>
<div class="image">
<img src="basic_compute.png" alt="basic_compute.png"/>
<div class="caption">
Basic particle system with compute!</div></div>
 <dl class="section note"><dt>Note</dt><dd>The source for this sample can be found in samples/basic_compute in the SDK.</dd></dl>
<h1><a class="anchor" id="basicComputeIntroduction"></a>
Introduction</h1>
<p>Compute shaders in Vulkan have first class support in the API. Compute shaders give applications the ability to perform non-graphics related tasks on the GPU.</p>
<dl class="section note"><dt>Note</dt><dd>This sample assumes you have some knowledge of how compute shaders work in other related graphics APIs such as OpenGL ES. This sample focuses on how to use compute shaders in Vulkan specifically, and not how compute shaders work in general.</dd></dl>
<p>This sample will demonstrate a very simple particle system. We will move the particles around on the GPU and render them to screen as additive blended point sprites.</p>
<h1><a class="anchor" id="basicComputePipeline"></a>
The Compute Pipeline</h1>
<p>Compute pipelines are significantly simpler to create than graphics pipelines as there is far less state to consider. In the compute shader we use two storage buffers which contain position data for the particles as well as velocity data.</p>
<div class="fragment"><div class="line">layout(<span class="keyword">set</span> = 0, binding = 0, std430) buffer Positions</div><div class="line">{</div><div class="line">    vec2 pos[];</div><div class="line">} positions;</div><div class="line"></div><div class="line">layout(<span class="keyword">set</span> = 0, binding = 1, std430) readonly buffer Velocity</div><div class="line">{</div><div class="line">    vec2 vel[];</div><div class="line">} velocities;</div></div><!-- fragment --><p>The shader itself is fairly simple. It nudges the particles around depending on position and velocity and moves them back to the center of the screen when they go out of bounds.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec2 current_pos = positions.pos[gl_GlobalInvocationID.x];</div><div class="line">    vec2 velocity = velocities.vel[gl_GlobalInvocationID.x];</div><div class="line">    current_pos += velocity;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (current_pos.x &gt; 0.95 ||</div><div class="line">        current_pos.x &lt; -0.95 ||</div><div class="line">        current_pos.y &gt; 0.95 ||</div><div class="line">        current_pos.y &lt; -0.95)</div><div class="line">    {</div><div class="line">        current_pos = -2.0 * velocity + current_pos * 0.05;</div><div class="line">    }</div><div class="line"></div><div class="line">    positions.pos[gl_GlobalInvocationID.x] = current_pos;</div><div class="line">}</div></div><!-- fragment --><p>We set up a pipeline layout similar to <a class="el" href="rotating_texture.html">Rotating Texture</a>.</p>
<div class="fragment"><div class="line">VkDescriptorSetLayoutBinding bindings[2] = { { 0 } };</div><div class="line">bindings[0].binding = 0;</div><div class="line">bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;</div><div class="line">bindings[0].descriptorCount = 1;</div><div class="line">bindings[0].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;</div><div class="line"></div><div class="line">bindings[1].binding = 1;</div><div class="line">bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;</div><div class="line">bindings[1].descriptorCount = 1;</div><div class="line">bindings[1].stageFlags = VK_SHADER_STAGE_COMPUTE_BIT;</div></div><!-- fragment --><p>We also create a descriptor pool and descriptor set similar to <a class="el" href="rotating_texture.html">Rotating Texture</a>. We create the compute pipeline by specifying the pipeline layout and the compute shader.</p>
<div class="fragment"><div class="line">initComputePipelineLayout();</div><div class="line">initComputeDescriptorSet();</div><div class="line"></div><div class="line">VkComputePipelineCreateInfo info = { VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO };</div><div class="line">info.stage.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;</div><div class="line">info.stage.stage = VK_SHADER_STAGE_COMPUTE_BIT;</div><div class="line">info.stage.module = loadShaderModule(device, <span class="stringliteral">&quot;shaders/particle.comp.spv&quot;</span>);</div><div class="line">info.stage.pName = <span class="stringliteral">&quot;main&quot;</span>;</div><div class="line">info.layout = computePipeline.pipelineLayout;</div><div class="line"></div><div class="line">VK_CHECK(vkCreateComputePipelines(device, pipelineCache, 1, &amp;info, <span class="keyword">nullptr</span>, &amp;computePipeline.pipeline));</div><div class="line"></div><div class="line"><span class="comment">// Pipeline is baked, we can delete the shader module now.</span></div><div class="line">vkDestroyShaderModule(device, info.stage.module, <span class="keyword">nullptr</span>);</div></div><!-- fragment --><h1><a class="anchor" id="basicComputeDrawPipe"></a>
The Graphics Pipeline</h1>
<p>After we have run compute to move the particles around, we still need a graphics pipeline to actually draw the particles. We set up a pipeline with POINT_LIST, two attributes for position and color and enable additive blending.</p>
<div class="fragment"><div class="line"><span class="comment">// Our attachment will write to all color channels, with additive blending.</span></div><div class="line">VkPipelineColorBlendAttachmentState blendAttachment = { 0 };</div><div class="line">blendAttachment.blendEnable = <span class="keyword">true</span>;</div><div class="line">blendAttachment.colorWriteMask = 0xf;</div><div class="line">blendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;</div><div class="line">blendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;</div><div class="line">blendAttachment.colorBlendOp = VK_BLEND_OP_ADD;</div><div class="line">blendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;</div><div class="line">blendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;</div><div class="line">blendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;</div></div><!-- fragment --><h1><a class="anchor" id="basicComputeRender"></a>
Rendering</h1>
<p>Our rendering callback will consist of two phases. First we run our compute workload, then begin a renderpass where we render the particles.</p>
<p>For synchronizing compute and vertex, we need to synchronize both ways in this case. We have a single buffer for position data. This means that while compute is running, we cannot run vertex shading. Similarly, while we're rendering the points, we cannot execute the compute shader. In terms of parallelism, this is still fine since the Mali GPU can parallelize and pipeline vertex/compute workloads with fragment shading.</p>
<p>Before dispatching compute, we add a barrier which will wait for all previous vertex shading to complete before starting any compute shading. After compute shading completes, we inject another barrier which blocks vertex shading until compute has completed. At the same time, we add the appropriate memory access flags.</p>
<div class="fragment"><div class="line"><span class="comment">// Compute</span></div><div class="line"><span class="comment">// First, we have to wait until previous vertex shader invocations have completed</span></div><div class="line"><span class="comment">// since we will overwrite the vertex buffer used in previous frame here.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// We only need execution barriers here and no memory barrier since we have a write-after-read hazard.</span></div><div class="line"><span class="comment">// Write-after-read only requires execution barriers.</span></div><div class="line"><span class="comment">// We have not touched the memory written by compute earlier, so no memory synchronization is needed.</span></div><div class="line">memoryBarrier(cmd, 0, 0, VK_PIPELINE_STAGE_VERTEX_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT);</div><div class="line"></div><div class="line"><span class="comment">// Bind the compute pipeline.</span></div><div class="line">vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, computePipeline.pipeline);</div><div class="line"></div><div class="line"><span class="comment">// Bind descriptor set.</span></div><div class="line">vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, computePipeline.pipelineLayout, 0, 1,</div><div class="line">                        &amp;computePipeline.descriptorSet, 0, <span class="keyword">nullptr</span>);</div><div class="line"></div><div class="line"><span class="comment">// Dispatch compute job.</span></div><div class="line">vkCmdDispatch(cmd, (positionBuffer.size / <span class="keyword">sizeof</span>(vec2)) / NUM_PARTICLES_PER_WORKGROUP, 1, 1);</div><div class="line"></div><div class="line"><span class="comment">// Barrier between compute and vertex shading.</span></div><div class="line">memoryBarrier(cmd, VK_ACCESS_SHADER_WRITE_BIT, VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,</div><div class="line">              VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_VERTEX_SHADER_BIT);</div></div><!-- fragment --><p>Now we can begin the render pass as normal, render the scene and submit to the swapchain as seen in <a class="el" href="hello_triangle.html">Hello Triangle</a>.</p>
<h1><a class="anchor" id="basicComputeGenerate"></a>
Generating the Initial Data</h1>
<p>All the particles in the scene are essentially randomized with random initial position, velocity and color.</p>
<div class="fragment"><div class="line">uniform_real_distribution&lt;float&gt; uniform(-1.0f, 1.0f);</div><div class="line">mt19937 engine;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; NUM_PARTICLES; i++)</div><div class="line">{</div><div class="line">        positions.push_back(vec2(0.2f * uniform(engine), 0.2f * uniform(engine)));</div><div class="line"></div><div class="line">        <span class="keywordtype">float</span> velocity = 0.008f + 0.003f * uniform(engine);</div><div class="line">        <span class="keywordtype">float</span> angle = 100.0f * uniform(engine);</div><div class="line"></div><div class="line">        velocities.push_back(velocity * vec2(glm::cos(angle), glm::sin(angle)));</div><div class="line"></div><div class="line">        <span class="keywordtype">float</span> y = 0.8f + 0.2f * uniform(engine);</div><div class="line">        <span class="keywordtype">float</span> saturation = 0.8f + 0.2f * uniform(engine);</div><div class="line">        <span class="keywordtype">float</span> hue = 100.0f * uniform(engine);</div><div class="line"></div><div class="line">        <span class="keywordtype">float</span> u = saturation * glm::cos(hue);</div><div class="line">        <span class="keywordtype">float</span> v = saturation * glm::sin(hue);</div><div class="line">        vec3 rgb = mat3(1.0f, 1.0f, 1.0f, 0.0f, -0.39465f, 2.03211f, 1.13983f, -0.58060f, 0.0f) * vec3(y, u, v);</div><div class="line">        colors.push_back(vec4(rgb, 0.4f));</div><div class="line">}</div><div class="line"></div><div class="line">positionBuffer = createBuffer(positions.data(), positions.size() * <span class="keyword">sizeof</span>(vec2),</div><div class="line">                              VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT);</div><div class="line">velocityBuffer = createBuffer(velocities.data(), velocities.size() * <span class="keyword">sizeof</span>(vec2),</div><div class="line">                              VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT);</div><div class="line">colorBuffer = createBuffer(colors.data(), colors.size() * <span class="keyword">sizeof</span>(vec4), VK_BUFFER_USAGE_VERTEX_BUFFER_BIT);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2016</a>
    </li>
  </ul>
</div>
</body>
</html>
