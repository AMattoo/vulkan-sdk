/**
\page astc Adaptive Scalable Texture Compression (ASTC) with ARM Mali

\brief Introduces how to use the ASTC compression standard for textures in Vulkan.

\image html astc.png "ASTC compressed at various bit-rates"

\note This sample will only run as intended on GPUs which support ASTC. For other GPUs, a fallback PNG will be displayed instead.

\section ASTCIntroduction Introduction

ASTC is a texture compression standard which currently represents the state of the art in GPU texture compression.
"Adaptive" and "Scalable" refer to important features:

 - Supports both LDR/HDR textures, although only LDR textures are part of core Vulkan.
 - Supports both 2D and 3D textures, although only 2D textures are part of core Vulkan.
 - Support for any number of color channels and uncorrelated channels for special purpose texture data.
 - Supports a wide range of quality settings ranging from 8bpp all the way down to less than 1bpp for 2D images in fine grained steps.
 - In LDR mode, UNORM and SRGB are supported.

For more information specifically about ASTC, please visit:
<a href="https://developer.arm.com/technologies/graphics-technologies/adaptive-scalable-texture-compression">ASTC Overview</a>

Texture compression is vital in order to reduce the size of games and other applications which rely heavily on textures.
An other aspect of texture compression is reducing bandwidth on the GPU which can improve performance and significantly reduce
power consumption.

For this sample we will demonstrate LDR ASTC at different quality settings from highest quality (4x4 blocks) down to
lowest (12x12 blocks).

\section ASTCEncoding Encoding images to ASTC

ASTC is an open standard and anyone can freely implement tools which decode and encode ASTC.
For this sample, we will use the reference ASTC compressor from ARM which can be found on <a href="https://github.com/ARM-software/astc-encoder">GitHub</a>.

\code
// Compresses PNG to ASTC header + payload, 4x4 blocks, thorough mode.
astcenc -c texture.png texture.astc 4x4 -thorough
\endcode

The ASTC payload format generated by astcenc consists of a 16 byte header, followed by the raw ASTC blocks.

\code
/// Header for the on-disk format generated by astcenc.
struct ASTCHeader
{
	/// Magic value
	uint8_t magic[4];
	/// Block size in X
	uint8_t blockdimX;
	/// Block size in Y
	uint8_t blockdimY;
	/// Block size in Z
	uint8_t blockdimZ;
	/// Size of the image in pixels (X), least significant byte first.
	uint8_t xsize[3];
	/// Size of the image in pixels (Y), least significant byte first.
	uint8_t ysize[3];
	/// Size of the image in pixels (Z), least significant byte first.
	uint8_t zsize[3];
};
static_assert(sizeof(ASTCHeader) == 16, "Packed ASTC header struct is not 16 bytes.");

#define ASTC_MAGIC 0x5CA1AB13
\endcode

\section ASTCDetection Detecting ASTC support

ASTC is a core feature in Vulkan, but supporting the format is optional.
To detect if ASTC is supported on your GPU, you can use

\code
// Check if the device supports ASTC textures.
VkFormatProperties properties;
vkGetPhysicalDeviceFormatProperties(pContext->getPhysicalDevice(), VK_FORMAT_ASTC_4x4_UNORM_BLOCK, &properties);
bool supportsASTC = (properties.optimalTilingFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT) != 0;
\endcode

\section ASTCUpload Uploading ASTC textures to GPU

Uploading ASTC textures is no different from uploading other images. Just like in the \ref rotatingTexture sample we will
use vkCmdCopyBufferToImage to copy our ASTC payload into the texture.

To load the image, we'll use the convenience function

\code
if (supportsASTC)
{
	LOGI("Device supports ASTC, loading ASTC texture!\n");
	if (FAILED(loadASTCTextureFromAsset(pPath, &buffer, &width, &height, &format)))
	{
		LOGE("Failed to load texture from asset.\n");
		abort();
	}
}
\endcode

If ASTC is not supported, we just load the fallback PNG texture.

\note For PNG input images, astcenc Y-flips the input texture, so we do the same for the fallback PNG texture. The vertex shader this time around applies the Y flip to get back to non-flipped input.

The only real difference between uploading compressed textures and uncompressed textures is that ASTC textures
use a different format, VK_FORMAT_ASTC_*. The entry points for creating textures and uploading them are the same.

\code
VkBufferImageCopy region = {};
region.bufferOffset = 0;
region.bufferRowLength = 0; // Tightly packed.
region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
region.imageSubresource.layerCount = 1;
region.imageExtent.width = width;
region.imageExtent.height = height;
region.imageExtent.depth = 1;

// Copy the buffer to our optimally tiled image. No difference between ASTC and uncompressed textures.
vkCmdCopyBufferToImage(cmd, stagingBuffer.buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);
\endcode

\section ASTCLinks Links

<a href="https://developer.arm.com/technologies/graphics-technologies/adaptive-scalable-texture-compression">ASTC Overview</a>

<a href="https://github.com/ARM-software/astc-encoder">ASTC Encoder - Github</a>

*/

