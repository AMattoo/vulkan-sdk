<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Mali Vulkan SDK for Android 1.1.0: Hello Triangle</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mali Vulkan SDK for Android 1.1.0
<span id="malidevcenter"><a href="http://malideveloper.arm.com">Mali Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hello_triangle.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Hello Triangle </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Introduction to "Hello Triangle", the most basic Vulkan application.</p>
<div class="image">
<img src="hello_triangle.png" alt="hello_triangle.png"/>
<div class="caption">
Our first triangle!</div></div>
 <dl class="section note"><dt>Note</dt><dd>The source for this sample can be found in samples/hellotriangle in the SDK.</dd></dl>
<h1><a class="anchor" id="helloTriangleIntro"></a>
Introduction</h1>
<p>In this sample, we will draw our first triangle to the screen. There are a lot of concepts to internalize for this sample.</p>
<h2><a class="anchor" id="helloTriangleSample"></a>
Structure of Samples</h2>
<p>All samples implement a global function which creates the application. This is so we can move the main loop outside every sample.</p>
<div class="fragment"><div class="line">VulkanApplication *MaliSDK::createApplication()</div><div class="line">{</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">new</span> HelloTriangle();</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="helloTriangleInitialize"></a>
Initialization</h1>
<p>The samples are initialized first once in VulkanApplication::initialize, then later the application will be called in updateSwapchain() every time the swapchain is invalidated or otherwise changes. Most initialization happens in updateSwapchain() since many of our resources will in some way depend on the swapchain.</p>
<p>We start off by creating a vertex buffer for our triangle, as well as creating a pipeline cache. The pipeline cache allows us to cache previously compiled pipelines and shaders if they are built multiple times. For this particular sample, it is strictly not necessary, but it is very useful to know about.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> HelloTriangle::initialize(Context *pContext)</div><div class="line">{</div><div class="line">        this-&gt;pContext = pContext;</div><div class="line"></div><div class="line">        <span class="comment">// Create the vertex buffer.</span></div><div class="line">        initVertexBuffer();</div><div class="line"></div><div class="line">        <span class="comment">// Create a pipeline cache (although we&#39;ll only create one pipeline).</span></div><div class="line">        VkPipelineCacheCreateInfo pipelineCacheInfo = { VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO };</div><div class="line">        VK_CHECK(vkCreatePipelineCache(pContext-&gt;getDevice(), &amp;pipelineCacheInfo, <span class="keyword">nullptr</span>, &amp;pipelineCache));</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="helloTriangleClipSpace"></a>
Top-left Always</h2>
<p>Vulkan's coordinate system is always top-left. This means that (X = -1, Y = -1) in normalized device coordinates will be top-left. This is opposite of OpenGL and OpenGL ES which is bottom-left.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> Vertex data[] = {</div><div class="line">        {</div><div class="line">                <span class="comment">// Positions                    // Color</span></div><div class="line">                vec4(-0.5f, -0.5f, 0.0f, 1.0f), vec4(1.0f, 0.0f, 0.0f, 1.0f),</div><div class="line">        },</div><div class="line">        {</div><div class="line">                vec4(-0.5f, +0.5f, 0.0f, 1.0f), vec4(0.0f, 1.0f, 0.0f, 1.0f),</div><div class="line">        },</div><div class="line">        {</div><div class="line">                vec4(+0.5f, -0.5f, 0.0f, 1.0f), vec4(0.0f, 0.0f, 1.0f, 1.0f),</div><div class="line">        },</div><div class="line">};</div><div class="line"></div><div class="line">vertexBuffer = createBuffer(data, <span class="keyword">sizeof</span>(data), VK_BUFFER_USAGE_VERTEX_BUFFER_BIT);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This triangle will have two vertices towards the top of the screen. It is still a counter-clockwise triangle, since the Vulkan specification negates the sign in its area computation when calculating the winding order.</dd></dl>
<h2><a class="anchor" id="helloTriangleBuffer"></a>
Creating a Buffer</h2>
<p>In order to create a buffer, we need to specify our usage as well as size.</p>
<div class="fragment"><div class="line">Buffer buffer;</div><div class="line">VkDevice device = pContext-&gt;getDevice();</div><div class="line"></div><div class="line">VkBufferCreateInfo info = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };</div><div class="line">info.usage = usage;</div><div class="line">info.size = size;</div><div class="line"></div><div class="line">VK_CHECK(vkCreateBuffer(device, &amp;info, <span class="keyword">nullptr</span>, &amp;buffer.buffer));</div></div><!-- fragment --><p>After creating a buffer, we have not allocated memory for it yet. To do this, we will need to query the requirements for the buffer.</p>
<p>The requirements of a buffer specify how much memory is required, alignment (needed if we place many buffers in a larger allocation), and which memory types can support this buffer.</p>
<p>A Vulkan device will support one or more memory types depending on the implementation. Integrated GPUs such as Mali will typically support one or two memory types, which typically distinguishes between cached memory or not.</p>
<p>Devices with ARM GPUs have a unified memory architecture such that both the CPU and GPU can access the same physical memory if the memory manager has been configured the right way.</p>
<div class="fragment"><div class="line"><span class="comment">// Ask device about its memory requirements.</span></div><div class="line">VkMemoryRequirements memReqs;</div><div class="line">vkGetBufferMemoryRequirements(device, buffer.buffer, &amp;memReqs);</div><div class="line"></div><div class="line">VkMemoryAllocateInfo alloc = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };</div><div class="line">alloc.allocationSize = memReqs.size;</div><div class="line"></div><div class="line"><span class="comment">// We want host visible and coherent memory to simplify things.</span></div><div class="line">alloc.memoryTypeIndex = findMemoryTypeFromRequirements(</div><div class="line">                memReqs.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);</div><div class="line"></div><div class="line">VK_CHECK(vkAllocateMemory(device, &amp;alloc, <span class="keyword">nullptr</span>, &amp;buffer.memory));</div><div class="line"></div><div class="line"><span class="comment">// Buffers are not backed by memory, so bind our memory explicitly to the buffer.</span></div><div class="line">vkBindBufferMemory(device, buffer.buffer, buffer.memory, 0);</div></div><!-- fragment --><p>Based on memReqs.memoryTypeBits, we get a bitmask which specifies which memory types this buffer can be backed by. These memory types might have different characteristics, so we need to match the available memory types with something that we can use, for example here, we need the buffer to be HOST_VISIBLE.</p>
<div class="fragment"><div class="line">uint32_t HelloTriangle::findMemoryTypeFromRequirements(uint32_t deviceRequirements, uint32_t hostRequirements)</div><div class="line">{</div><div class="line">        <span class="keyword">const</span> VkPhysicalDeviceMemoryProperties &amp;props = pContext-&gt;getPlatform().getMemoryProperties();</div><div class="line">        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; VK_MAX_MEMORY_TYPES; i++)</div><div class="line">        {</div><div class="line">                <span class="keywordflow">if</span> (deviceRequirements &amp; (1u &lt;&lt; i))</div><div class="line">                {</div><div class="line">                        <span class="keywordflow">if</span> ((props.memoryTypes[i].propertyFlags &amp; hostRequirements) == hostRequirements)</div><div class="line">                        {</div><div class="line">                                <span class="keywordflow">return</span> i;</div><div class="line">                        }</div><div class="line">                }</div><div class="line">        }</div><div class="line"></div><div class="line">        LOGE(<span class="stringliteral">&quot;Failed to obtain suitable memory type.\n&quot;</span>);</div><div class="line">        abort();</div><div class="line">}</div></div><!-- fragment --><p>To "upload" our data to the buffer, we can simply map it, and copy. There is no requirement in Vulkan that we unmap the buffer before using it, but we will not modify this buffer any more, so unmapping makes sense.</p>
<div class="fragment"><div class="line"><span class="comment">// Map the memory and dump data in there.</span></div><div class="line"><span class="keywordflow">if</span> (pInitialData)</div><div class="line">{</div><div class="line">        <span class="keywordtype">void</span> *pData;</div><div class="line">        VK_CHECK(vkMapMemory(device, buffer.memory, 0, size, 0, &amp;pData));</div><div class="line">        memcpy(pData, pInitialData, size);</div><div class="line">        vkUnmapMemory(device, buffer.memory);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="helloTriangleRenderPass"></a>
Creating the Renderpass</h2>
<p>In Vulkan, we need to specify a render pass up front. Which attachments will we use, are we going to clear the render target on start? Will we preserve any attachments? All these decisions are crucial for a tile based architecture such as Mali.</p>
<p>For this sample, we only have a single color buffer which we render a triangle to. First, we specify our attachment.</p>
<div class="fragment"><div class="line">VkAttachmentDescription attachment = { 0 };</div><div class="line"><span class="comment">// Backbuffer format.</span></div><div class="line">attachment.format = format;</div><div class="line"><span class="comment">// Not multisampled.</span></div><div class="line">attachment.samples = VK_SAMPLE_COUNT_1_BIT;</div><div class="line"><span class="comment">// When starting the frame, we want tiles to be cleared.</span></div><div class="line">attachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</div><div class="line"><span class="comment">// When end the frame, we want tiles to be written out.</span></div><div class="line">attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;</div><div class="line"><span class="comment">// Don&#39;t care about stencil since we&#39;re not using it.</span></div><div class="line">attachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</div><div class="line">attachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</div><div class="line"></div><div class="line"><span class="comment">// The image layout will be undefined when the render pass begins.</span></div><div class="line">attachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</div><div class="line"><span class="comment">// After the render pass is complete, we will transition to PRESENT_SRC_KHR layout.</span></div><div class="line">attachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;</div></div><!-- fragment --><h3><a class="anchor" id="helloTriangleSubPass"></a>
Creating the Subpass</h3>
<p>Inside a renderpass, there can be multiple subpasses. For now, we can make it simple and just assume a single subpass. In the subpass we specify that we have a single color attachment.</p>
<div class="fragment"><div class="line"><span class="comment">// We have one subpass.</span></div><div class="line"><span class="comment">// This subpass has 1 color attachment.</span></div><div class="line"><span class="comment">// While executing this subpass, the attachment will be in attachment optimal layout.</span></div><div class="line">VkAttachmentReference colorRef = { 0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL };</div><div class="line">VkSubpassDescription subpass = { 0 };</div><div class="line">subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;</div><div class="line">subpass.colorAttachmentCount = 1;</div><div class="line">subpass.pColorAttachments = &amp;colorRef;</div><div class="line"></div><div class="line"><span class="comment">// Finally, create the renderpass.</span></div><div class="line">VkRenderPassCreateInfo rpInfo = { VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO };</div><div class="line">rpInfo.attachmentCount = 1;</div><div class="line">rpInfo.pAttachments = &amp;attachment;</div><div class="line">rpInfo.dependencyCount = 1;</div><div class="line">rpInfo.pDependencies = &amp;dependency;</div><div class="line">rpInfo.subpassCount = 1;</div><div class="line">rpInfo.pSubpasses = &amp;subpass;</div><div class="line">VK_CHECK(vkCreateRenderPass(pContext-&gt;getDevice(), &amp;rpInfo, <span class="keyword">nullptr</span>, &amp;renderPass));</div></div><!-- fragment --><h3><a class="anchor" id="helloTriangleTransition"></a>
Image Layout Transitions</h3>
<p>Before we start rendering, we need to make an image layout transition. This is a completely new concept in Vulkan if you are used to older graphics APIs. The purpose of an image layout is to allow the GPU to better optimize based on how an image is being accessed. VK_IMAGE_LAYOUT_GENERAL is a generic layout that will work in all cases, but could be suboptimal on certain GPUs.</p>
<dl class="section note"><dt>Note</dt><dd>For Mali GPUs in particular, VK_IMAGE_LAYOUT_GENERAL is just as good as any "optimal" layout, but in this sample, we try to take the "correct" route, which should be optimal on any GPU that supports Vulkan. Even if we were to always go with IMAGE_LAYOUT_GENERAL, we still need to make layout transitions into PRESENT_SRC_KHR for images which are part of the swapchain, so it's not something we can entirely ignore.</dd></dl>
<p>We make use of render pass attachments to do our layout transition. We want to transition into the COLOR_ATTACHMENT_OUTPUT_BIT. At the start of the frame, we will clear the image, so we do not care about preserving any of the image. In this case we can transition from an "undefined" layout, which effectively invalidates any data found in the render target.</p>
<p>In our render pass, we can describe how image layouts will change over time. We need to describe the initial state of a render target attachment:</p>
<div class="fragment"><div class="line">attachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</div></div><!-- fragment --><p>The application must ensure that the layout used here is accurate. Vulkan will not transition anything into the initialLayout for you. The special case here is UNDEFINED layout, since it effectively means you don't care about the layout.</p>
<p>When a subpass begins, images are transitioned into an image layout. This image layout depends on the VkAttachmentReference. In our case, we want COLOR_ATTACHMENT_OPTIMAL.</p>
<div class="fragment"><div class="line">VkAttachmentReference colorRef = { 0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL };</div></div><!-- fragment --><p>After all subpasses are complete, there is a final transition to the finalLayout.</p>
<div class="fragment"><div class="line">attachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;</div></div><!-- fragment --><p>This creates the desired effect that we invalidate, transition to ATTACHMENT_OPTIMAL while we render, then finally transition to PRESENT_SRC_KHR. This image can now be presented.</p>
<h3><a class="anchor" id="helloTriangleExternalSubpass"></a>
Adding Subpass Dependency</h3>
<p>The image layout transition as part of a subpass will happen without any waiting. This is bad because the presentation engine can still be reading from the image. To properly enforce this we need to add an external dependency to our first subpass where the layout transition happens.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a dependency to external events.</span></div><div class="line"><span class="comment">// We need to wait for the WSI semaphore to signal.</span></div><div class="line"><span class="comment">// Only pipeline stages which depend on COLOR_ATTACHMENT_OUTPUT_BIT will</span></div><div class="line"><span class="comment">// actually wait for the semaphore, so we must also wait for that pipeline stage.</span></div><div class="line">VkSubpassDependency dependency = { 0 };</div><div class="line">dependency.srcSubpass = VK_SUBPASS_EXTERNAL;</div><div class="line">dependency.dstSubpass = 0;</div><div class="line">dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</div><div class="line">dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</div><div class="line"><span class="comment">// We are creating a write-after-read dependency (presentation must be done reading), so we don&#39;t need memory barrier.</span></div><div class="line">dependency.srcAccessMask = 0;</div><div class="line"><span class="comment">// The layout transition to COLOR_ATTACHMENT_OPTIMAL will imply a memory barrier for the relevant access bits, so we don&#39;t have to do it.</span></div><div class="line">dependency.dstAccessMask = 0;</div></div><!-- fragment --><p>As source subpass we use EXTERNAL, which means that we wait for something outside the renderpass itself to complete before we begin the first subpass. An important point here is that we use COLOR_ATTACHMENT_OUTPUT_BIT as our StageMask. When we later submit our command buffer we will only let a certain pipeline stage wait for our semaphore. By having our subpass dependency wait for that stage we create a dependency chain which ensures that the layout transition happens after the semaphore signals.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> VkPipelineStageFlags waitStage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</div><div class="line">info.waitSemaphoreCount = acquireSemaphore != VK_NULL_HANDLE ? 1 : 0;</div><div class="line">info.pWaitSemaphores = &amp;acquireSemaphore;</div><div class="line">info.pWaitDstStageMask = &amp;waitStage;</div></div><!-- fragment --><p>Only the fragment parts of the graphics pipeline needs to wait. Vertex can run completely in parallel.</p>
<h2><a class="anchor" id="helloTrianglePipeline"></a>
Creating the Pipeline</h2>
<p>In Vulkan, a lot of state which affects rendering is bundled together into a large blob called the VkPipeline. The pipeline specifies which shaders to use, blend state, depth stencil state, and much more. It is a huge block of state.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>VkGraphicsPipelineCreateInfo {</div><div class="line">    VkStructureType                                  sType;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">void</span>*                                      pNext;</div><div class="line">    VkPipelineCreateFlags                            flags;</div><div class="line">    uint32_t                                         stageCount;</div><div class="line">    <span class="keyword">const</span> VkPipelineShaderStageCreateInfo*           pStages;</div><div class="line">    <span class="keyword">const</span> VkPipelineVertexInputStateCreateInfo*      pVertexInputState;</div><div class="line">    <span class="keyword">const</span> VkPipelineInputAssemblyStateCreateInfo*    pInputAssemblyState;</div><div class="line">    <span class="keyword">const</span> VkPipelineTessellationStateCreateInfo*     pTessellationState;</div><div class="line">    <span class="keyword">const</span> VkPipelineViewportStateCreateInfo*         pViewportState;</div><div class="line">    <span class="keyword">const</span> VkPipelineRasterizationStateCreateInfo*    pRasterizationState;</div><div class="line">    <span class="keyword">const</span> VkPipelineMultisampleStateCreateInfo*      pMultisampleState;</div><div class="line">    <span class="keyword">const</span> VkPipelineDepthStencilStateCreateInfo*     pDepthStencilState;</div><div class="line">    <span class="keyword">const</span> VkPipelineColorBlendStateCreateInfo*       pColorBlendState;</div><div class="line">    <span class="keyword">const</span> VkPipelineDynamicStateCreateInfo*          pDynamicState;</div><div class="line">    VkPipelineLayout                                 layout;</div><div class="line">    VkRenderPass                                     renderPass;</div><div class="line">    uint32_t                                         subpass;</div><div class="line">    VkPipeline                                       basePipelineHandle;</div><div class="line">    int32_t                                          basePipelineIndex;</div><div class="line">} VkGraphicsPipelineCreateInfo;</div></div><!-- fragment --><p>The advantage of doing this is that the driver has full knowledge up front how rendering will happen. Also, when we later want to use the pipeline, we can bind it all in one go to a command buffer instead of making many separate calls.</p>
<p>The pipeline setup here is not very exciting. The main thing we need to set up is our vertex input structure. We have a vertex buffer with interleaved position and color data, which needs to be specified.</p>
<div class="fragment"><div class="line"><span class="comment">// Specify our two attributes, Position and Color.</span></div><div class="line">VkVertexInputAttributeDescription attributes[2] = { { 0 } };</div><div class="line">attributes[0].location = 0; <span class="comment">// Position in shader specifies layout(location = 0) to link with this attribute.</span></div><div class="line">attributes[0].binding = 0;</div><div class="line">attributes[0].format = VK_FORMAT_R32G32B32A32_SFLOAT;</div><div class="line">attributes[0].offset = 0;</div><div class="line">attributes[1].location = 1; <span class="comment">// Color in shader specifies layout(location = 1) to link with this attribute.</span></div><div class="line">attributes[1].binding = 0;</div><div class="line">attributes[1].format = VK_FORMAT_R32G32B32A32_SFLOAT;</div><div class="line">attributes[1].offset = 4 * <span class="keyword">sizeof</span>(float);</div><div class="line"></div><div class="line"><span class="comment">// We have one vertex buffer, with stride 8 floats (vec4 + vec4).</span></div><div class="line">VkVertexInputBindingDescription binding = { 0 };</div><div class="line">binding.binding = 0;</div><div class="line">binding.stride = <span class="keyword">sizeof</span>(Vertex);</div><div class="line">binding.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;</div></div><!-- fragment --><h3><a class="anchor" id="helloTriangleShaders"></a>
Using SPIR-V Shaders</h3>
<div class="fragment"><div class="line"><span class="comment">// Load our SPIR-V shaders.</span></div><div class="line">VkPipelineShaderStageCreateInfo shaderStages[2] = {</div><div class="line">        { VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO },</div><div class="line">        { VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO },</div><div class="line">};</div><div class="line"></div><div class="line">shaderStages[0].stage = VK_SHADER_STAGE_VERTEX_BIT;</div><div class="line">shaderStages[0].module = loadShaderModule(device, <span class="stringliteral">&quot;shaders/triangle.vert.spv&quot;</span>);</div><div class="line">shaderStages[0].pName = <span class="stringliteral">&quot;main&quot;</span>;</div><div class="line">shaderStages[1].stage = VK_SHADER_STAGE_FRAGMENT_BIT;</div><div class="line">shaderStages[1].module = loadShaderModule(device, <span class="stringliteral">&quot;shaders/triangle.frag.spv&quot;</span>);</div><div class="line">shaderStages[1].pName = <span class="stringliteral">&quot;main&quot;</span>;</div><div class="line"></div><div class="line">VkGraphicsPipelineCreateInfo pipe = { VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO };</div><div class="line">pipe.stageCount = 2;</div><div class="line">pipe.pStages = shaderStages;</div><div class="line">...</div></div><!-- fragment --><div class="fragment"><div class="line">VkShaderModule loadShaderModule(VkDevice device, <span class="keyword">const</span> <span class="keywordtype">char</span> *pPath)</div><div class="line">{</div><div class="line">        vector&lt;uint32_t&gt; buffer;</div><div class="line">        <span class="keywordflow">if</span> (FAILED(OS::getAssetManager().readBinaryFile(&amp;buffer, pPath)))</div><div class="line">        {</div><div class="line">                LOGE(<span class="stringliteral">&quot;Failed to read SPIR-V file: %s.\n&quot;</span>, pPath);</div><div class="line">                <span class="keywordflow">return</span> VK_NULL_HANDLE;</div><div class="line">        }</div><div class="line"></div><div class="line">        VkShaderModuleCreateInfo moduleInfo = { VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO };</div><div class="line">        moduleInfo.codeSize = buffer.size() * <span class="keyword">sizeof</span>(uint32_t);</div><div class="line">        moduleInfo.pCode = buffer.data();</div><div class="line"></div><div class="line">        VkShaderModule shaderModule;</div><div class="line">        VK_CHECK(vkCreateShaderModule(device, &amp;moduleInfo, <span class="keyword">nullptr</span>, &amp;shaderModule));</div><div class="line">        <span class="keywordflow">return</span> shaderModule;</div><div class="line">}</div></div><!-- fragment --><p>The SPIR-V binary shaders have been built in the build system via CMake.</p>
<h2><a class="anchor" id="helloTriangleFramebuffer"></a>
Building VkImageView and VkFramebuffer for Swapchain Images</h2>
<p>In the updateSwapchain callback, we know which swapchain images we will render the triangles to. We create the required number of VkImageViews and VkFramebuffers.</p>
<p>In Vulkan, when images are used for rendering or sampling, we need to create an "image view". The image view describes how we will interpret the image we create the view from. We might have a mipmapped texture where we create a single mip-level image, or we can reinterpret the format. In this scenario however, we will simply create an "identity" view.</p>
<p>When creating a framebuffer, we give it the attachments we will use, and these attachments must be VkImageViews. We need to create separate image views and framebuffers for each swapchain image that is in use, since we can be asked to render into any of the swapchain images.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> image : newBackbuffers)</div><div class="line">{</div><div class="line">        <span class="comment">// Create an image view which we can render into.</span></div><div class="line">        VkImageViewCreateInfo view = { VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO };</div><div class="line">        view.viewType = VK_IMAGE_VIEW_TYPE_2D;</div><div class="line">        view.format = dim.format;</div><div class="line">        view.image = image;</div><div class="line">        view.subresourceRange.baseMipLevel = 0;</div><div class="line">        view.subresourceRange.baseArrayLayer = 0;</div><div class="line">        view.subresourceRange.levelCount = 1;</div><div class="line">        view.subresourceRange.layerCount = 1;</div><div class="line">        view.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div><div class="line">        view.components.r = VK_COMPONENT_SWIZZLE_R;</div><div class="line">        view.components.g = VK_COMPONENT_SWIZZLE_G;</div><div class="line">        view.components.b = VK_COMPONENT_SWIZZLE_B;</div><div class="line">        view.components.a = VK_COMPONENT_SWIZZLE_A;</div><div class="line"></div><div class="line">        VK_CHECK(vkCreateImageView(device, &amp;view, <span class="keyword">nullptr</span>, &amp;backbuffer.view));</div><div class="line"></div><div class="line">        <span class="comment">// Build the framebuffer.</span></div><div class="line">        VkFramebufferCreateInfo fbInfo = { VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO };</div><div class="line">        fbInfo.renderPass = renderPass;</div><div class="line">        fbInfo.attachmentCount = 1;</div><div class="line">        fbInfo.pAttachments = &amp;backbuffer.view;</div><div class="line">        fbInfo.width = width;</div><div class="line">        fbInfo.height = height;</div><div class="line">        fbInfo.layers = 1;</div><div class="line"></div><div class="line">        VK_CHECK(vkCreateFramebuffer(device, &amp;fbInfo, <span class="keyword">nullptr</span>, &amp;backbuffer.framebuffer));</div><div class="line"></div><div class="line">        backbuffers.push_back(backbuffer);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="helloTriangleRenderLoop"></a>
Rendering a Frame</h1>
<p>Finally, we can start rendering to the screen. First of all, we need a command buffer which we can record into.</p>
<h2><a class="anchor" id="helloTriangleRequest"></a>
Requesting Command Buffer</h2>
<div class="fragment"><div class="line"><span class="comment">// Request a fresh command buffer.</span></div><div class="line">VkCommandBuffer cmd = pContext-&gt;requestPrimaryCommandBuffer();</div></div><!-- fragment --><p>The command buffer is allocated from a VkCommandPool which is tied to the swapchainIndex.</p>
<div class="fragment"><div class="line">VkCommandBuffer Context::requestPrimaryCommandBuffer()</div><div class="line">{</div><div class="line">        <span class="keywordflow">return</span> perFrame[swapchainIndex]-&gt;commandManager.requestCommandBuffer();</div><div class="line">}</div><div class="line"></div><div class="line">VkCommandBuffer CommandBufferManager::requestCommandBuffer()</div><div class="line">{</div><div class="line">        <span class="comment">// Either we recycle a previously allocated command buffer, or create a new one.</span></div><div class="line">        VkCommandBuffer ret = VK_NULL_HANDLE;</div><div class="line">        <span class="keywordflow">if</span> (count &lt; buffers.size())</div><div class="line">        {</div><div class="line">                ret = buffers[count++];</div><div class="line">                VK_CHECK(vkResetCommandBuffer(ret, VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">                VkCommandBufferAllocateInfo info = { VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO };</div><div class="line">                info.commandPool = pool;</div><div class="line">                info.level = commandBufferLevel;</div><div class="line">                info.commandBufferCount = 1;</div><div class="line">                VK_CHECK(vkAllocateCommandBuffers(device, &amp;info, &amp;ret));</div><div class="line">                buffers.push_back(ret);</div><div class="line"></div><div class="line">                count++;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> ret;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="helloTriangleAsync"></a>
Asynchronous GPU</h2>
<p>It is crucial that we have some system in place for allocating command buffers. In Vulkan, submissions to the GPU are asynchronous. This means that when we submit a command buffer to the GPU, we cannot reuse it or touch it until we are certain the GPU has completed the work. While the GPU is working with a command buffer, we need to start queueing up work to a different command buffer. The next frame we will observe a different swapchainIndex, so we will allocate a command buffer from a different pool, which avoids all hazards like these.</p>
<p>We begin the command buffer and specify that we only intend to submit it once. This allows the driver to make certain optimizations based on this knowledge since the command buffer can potentially be scribbled on in-place without having to worry about maintaining a clean copy of the command buffer.</p>
<h2><a class="anchor" id="helloTriangleBeginRenderPass"></a>
Beginning the Renderpass</h2>
<p>To begin a renderpass, we need to specify the clear color values, the framebuffer we render into, the render pass and the extents of our rendering.</p>
<div class="fragment"><div class="line"><span class="comment">// Set clear color values.</span></div><div class="line">VkClearValue clearValue;</div><div class="line">clearValue.color.float32[0] = 0.1f;</div><div class="line">clearValue.color.float32[1] = 0.1f;</div><div class="line">clearValue.color.float32[2] = 0.2f;</div><div class="line">clearValue.color.float32[3] = 1.0f;</div><div class="line"></div><div class="line"><span class="comment">// Begin the render pass.</span></div><div class="line">VkRenderPassBeginInfo rpBegin = { VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO };</div><div class="line">rpBegin.renderPass = renderPass;</div><div class="line">rpBegin.framebuffer = backbuffer.framebuffer;</div><div class="line">rpBegin.renderArea.extent.width = width;</div><div class="line">rpBegin.renderArea.extent.height = height;</div><div class="line">rpBegin.clearValueCount = 1;</div><div class="line">rpBegin.pClearValues = &amp;clearValue;</div><div class="line">vkCmdBeginRenderPass(cmd, &amp;rpBegin, VK_SUBPASS_CONTENTS_INLINE);</div></div><!-- fragment --><p>The actual render pass is fairly simple. First, we bind a pipeline to the command buffer.</p>
<div class="fragment"><div class="line"><span class="comment">// Bind the graphics pipeline.</span></div><div class="line">vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline);</div></div><!-- fragment --><p>We then specify dynamic state such as the viewport and scissor box. Here, we just use the full framebuffer size.</p>
<div class="fragment"><div class="line"><span class="comment">// Set up dynamic state.</span></div><div class="line"><span class="comment">// Viewport</span></div><div class="line">VkViewport vp = { 0 };</div><div class="line">vp.x = 0.0f;</div><div class="line">vp.y = 0.0f;</div><div class="line">vp.width = float(width);</div><div class="line">vp.height = float(height);</div><div class="line">vp.minDepth = 0.0f;</div><div class="line">vp.maxDepth = 1.0f;</div><div class="line">vkCmdSetViewport(cmd, 0, 1, &amp;vp);</div><div class="line"></div><div class="line"><span class="comment">// Scissor box</span></div><div class="line">VkRect2D scissor;</div><div class="line">memset(&amp;scissor, 0, <span class="keyword">sizeof</span>(scissor));</div><div class="line">scissor.extent.width = width;</div><div class="line">scissor.extent.height = height;</div><div class="line">vkCmdSetScissor(cmd, 0, 1, &amp;scissor);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is possible to bake the viewport and scissor state into the VkPipeline itself, but in this sample, we explicitly defined that VIEWPORT and SCISSOR state should be dynamic and modifyable outside the pipeline.</dd></dl>
<p>We can now bind our vertex buffer, draw the triangle, and finally, end the render pass.</p>
<div class="fragment"><div class="line"><span class="comment">// Bind vertex buffer.</span></div><div class="line">VkDeviceSize offset = 0;</div><div class="line">vkCmdBindVertexBuffers(cmd, 0, 1, &amp;vertexBuffer.buffer, &amp;offset);</div><div class="line"></div><div class="line"><span class="comment">// Draw three vertices with one instance.</span></div><div class="line">vkCmdDraw(cmd, 3, 1, 0, 0);</div><div class="line"></div><div class="line"><span class="comment">// Complete render pass.</span></div><div class="line">vkCmdEndRenderPass(cmd);</div></div><!-- fragment --><p>We can now end our command buffer and submit it to the device.</p>
<div class="fragment"><div class="line"><span class="comment">// Complete the command buffer.</span></div><div class="line">VK_CHECK(vkEndCommandBuffer(cmd));</div><div class="line"></div><div class="line"><span class="comment">// Submit it to the queue.</span></div><div class="line">pContext-&gt;submitSwapchain(cmd);</div></div><!-- fragment --><p>When we submit a command buffer which interacts with the swapchain, we need to make sure of Vulkan semaphores. When we acquired the swapchain image, we provided an acquireSemaphore which will be signalled later on the GPU when it becomes safe to render into the image.</p>
<p>When submitting a command buffer, we also specify that we need to wait for a semaphore first. We can also specify that only the COLOR_ATTACHMENT_OUTPUT_BIT stage actually needs to be blocked. We can still perform vertex processing or other tasks without blocking on the swapchain. This is critical for getting optimal parallelism for tiled GPUs such as Mali.</p>
<p>After the command buffer completes, we need to signal a release semaphore. This semaphore is then used in vkQueuePresentKHR which needs to wait for the GPU to complete rendering in order to correctly display results on screen.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Context::submitSwapchain(VkCommandBuffer cmd)</div><div class="line">{</div><div class="line">        submitCommandBuffer(cmd, getSwapchainAcquireSemaphore(), getSwapchainReleaseSemaphore());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Context::submitCommandBuffer(VkCommandBuffer cmd, VkSemaphore acquireSemaphore, VkSemaphore releaseSemaphore)</div><div class="line">{</div><div class="line">        <span class="comment">// All queue submissions get a fence that CPU will wait</span></div><div class="line">        <span class="comment">// on for synchronization purposes.</span></div><div class="line">        VkFence fence = getFenceManager().requestClearedFence();</div><div class="line"></div><div class="line">        VkSubmitInfo info = { VK_STRUCTURE_TYPE_SUBMIT_INFO };</div><div class="line">        info.commandBufferCount = 1;</div><div class="line">        info.pCommandBuffers = &amp;cmd;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> VkPipelineStageFlags waitStage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</div><div class="line">        info.waitSemaphoreCount = acquireSemaphore != VK_NULL_HANDLE ? 1 : 0;</div><div class="line">        info.pWaitSemaphores = &amp;acquireSemaphore;</div><div class="line">        info.pWaitDstStageMask = &amp;waitStage;</div><div class="line">        info.signalSemaphoreCount = releaseSemaphore != VK_NULL_HANDLE ? 1 : 0;</div><div class="line">        info.pSignalSemaphores = &amp;releaseSemaphore;</div><div class="line"></div><div class="line">        VK_CHECK(vkQueueSubmit(queue, 1, &amp;info, fence));</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="helloTriangleFences"></a>
Using Fences to Keep Track of GPU Progress</h2>
<p>When we submit a command buffer to the GPU, we do not wait on the CPU. In theory, we could queue up as many frames as we wish for, but this has an effect on latency and the fact that we need to keep track of a lot of command buffers. We typically only want to queue up 2-3 frames at most in order to keep both CPU and GPU busy. When GPU has enough work to do, we want to wait on the CPU until the GPU completes more work.</p>
<p>We implement this by keeping a list of fences which were triggered for a given swapchainIndex.</p>
<div class="fragment"><div class="line"><span class="comment">// All queue submissions get a fence that CPU will wait</span></div><div class="line"><span class="comment">// on for synchronization purposes.</span></div><div class="line">VkFence fence = getFenceManager().requestClearedFence();</div><div class="line"></div><div class="line">FenceManager &amp;Context::getFenceManager()</div><div class="line">{</div><div class="line">        <span class="keywordflow">return</span> perFrame[swapchainIndex]-&gt;fenceManager;</div><div class="line">}</div></div><!-- fragment --><p>The next time we observe a swapchain index in AcquireNextImageKHR, we can wait for all the fences which belong to that swapchain index. This allows us to cleanly bound the latency to a fixed number of frames with optimal throughput. After acquiring a swapchain index, we wait for the fences in question in Context::beginFrame().</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Context::PerFrame::beginFrame()</div><div class="line">{</div><div class="line">        fenceManager.beginFrame();</div><div class="line">        commandManager.beginFrame();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;pManager : secondaryCommandManagers)</div><div class="line">                pManager-&gt;beginFrame();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> FenceManager::beginFrame()</div><div class="line">{</div><div class="line">        <span class="comment">// If we have outstanding fences for this swapchain image, wait for them to complete first.</span></div><div class="line">        <span class="comment">// Normally, this doesn&#39;t really block at all,</span></div><div class="line">        <span class="comment">// since we&#39;re waiting for old frames to have been completed, but just in case.</span></div><div class="line">        <span class="keywordflow">if</span> (count != 0)</div><div class="line">        {</div><div class="line">                vkWaitForFences(device, count, fences.data(), <span class="keyword">true</span>, UINT64_MAX);</div><div class="line">                vkResetFences(device, count, fences.data());</div><div class="line">        }</div><div class="line">        count = 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2016</a>
    </li>
  </ul>
</div>
</body>
</html>
