<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Vulkan SDK for Android 1.1.1: Mipmapping in Vulkan</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vulkan SDK for Android 1.1.1
<span id="malidevcenter"><a href="http://malideveloper.arm.com">Mali Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mipmapping.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Mipmapping in Vulkan </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Introduces how to use mipmaps and how to generate them from a source image.</p>
<div class="image">
<img src="mipmapping_manually_generated.gif" alt="mipmapping_manually_generated.gif"/>
<div class="caption">
Using mipmaps in Vulkan: the quad on the right shows the mip level used for each highlighted quad on the left</div></div>
 <dl class="section note"><dt>Note</dt><dd>The source for this sample can be found in samples/mipmapping in the SDK.</dd></dl>
<h1><a class="anchor" id="mipmappingIntroduction"></a>
Introduction</h1>
<p>This sample builds on the <a class="el" href="rotating_texture.html">Rotating Texture</a> sample. It implements mipmapping in two ways, by loading pre-scaled images and by generating mipmaps from a single image. The mip levels for each case are displayed as shown in the image above.</p>
<p>In this tutorial we will go through the steps needed to implement both mipmapping approaches.</p>
<h1><a class="anchor" id="mipmappingLoadingMipmappedTexture"></a>
Loading a mipmapped texture from pre-scaled images</h1>
<p>Let us start with the simplest case, in which we want to create a mipmapped texture by importing already scaled images. For that purpose, we will modify the createTextureFromAsset function into createMipmappedTextureFromAssets, which accepts a vector of paths instead of a single one.</p>
<p>It is convenient to store the data for each mip level that we will load in a struct, MipLevel. The first part of the function is then a straightforward modification from the original one, just by iterating through the images we want to load:</p>
<div class="fragment"><div class="line">vector&lt;MipLevel&gt; mipLevels;</div><div class="line"><span class="keywordtype">unsigned</span> mipLevelCount;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;pPath : pPaths)</div><div class="line">{</div><div class="line">        MipLevel mipLevel;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (FAILED(loadRgba8888TextureFromAsset(pPath, &amp;mipLevel.buffer, &amp;mipLevel.width, &amp;mipLevel.height)))</div><div class="line">        {</div><div class="line">                LOGE(<span class="stringliteral">&quot;Failed to load texture from asset.\n&quot;</span>);</div><div class="line">                abort();</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Copy commands such as vkCmdCopyBufferToImage will need TRANSFER_SRC_BIT.</span></div><div class="line">        mipLevel.stagingBuffer = createBuffer(mipLevel.buffer.data(), mipLevel.width * mipLevel.height * 4, VK_BUFFER_USAGE_TRANSFER_SRC_BIT);</div><div class="line"></div><div class="line">        mipLevels.push_back(mipLevel);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Get the number of mip levels based on the number of loaded sources.</span></div><div class="line">mipLevelCount = mipLevels.size();</div></div><!-- fragment --><p>Small changes are necessary to the structures for creating the VkImage and the VkImageView, which need to be aware of the number of mip levels.</p>
<p>We can now move to actually loading data from the staging buffers to the mip levels of the texture. Please note that in the final version the first mip level (i.e. the iteration with i = 0) is isolated; this will be useful when generating mipmaps, but for the time being we can simplify the code.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; mipLevelCount; i++)</div><div class="line">{</div><div class="line">        VkBufferImageCopy region = {};</div><div class="line">        region.bufferOffset = 0;</div><div class="line">        region.bufferRowLength = mipLevels[i].width;</div><div class="line">        region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div><div class="line">        region.imageSubresource.mipLevel = i;</div><div class="line">        region.imageSubresource.layerCount = 1;</div><div class="line">        region.imageExtent.width = mipLevels[i].width;</div><div class="line">        region.imageExtent.height = mipLevels[i].height;</div><div class="line">        region.imageExtent.depth = 1;</div><div class="line"></div><div class="line">        <span class="comment">// Copy each staging buffer to the appropriate mip level of our optimally tiled image.</span></div><div class="line">        vkCmdCopyBufferToImage(cmd, mipLevels[i].stagingBuffer.buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &amp;region);</div><div class="line">}</div></div><!-- fragment --><p>The function vkCmdCopyBufferToImage (already used in <a class="el" href="rotating_texture.html">Rotating Texture</a>) is able to copy data to specific mip level of the destination image, just by specifying it in the region structure. No memory barrier is needed between such copies, but we must keep the barrier at the end to ensure that no fragment shading is done while we are copying the texture from the staging buffers.</p>
<p>The rest of the function requires few other minor modifications, such as freeing all the temporary resources and passing the maximum LOD to the sampler.</p>
<p>Everything is ready, we can now call our new function to load a mipmapped texture:</p>
<div class="fragment"><div class="line"><span class="comment">// Load texture with pre-generated mipmaps.</span></div><div class="line">vector&lt;char const *&gt; pPaths = { <span class="stringliteral">&quot;textures/T_Speaker_512.png&quot;</span>, <span class="stringliteral">&quot;textures/T_Speaker_256.png&quot;</span>, <span class="stringliteral">&quot;textures/T_Speaker_128.png&quot;</span>,</div><div class="line">                                <span class="stringliteral">&quot;textures/T_Speaker_64.png&quot;</span>,  <span class="stringliteral">&quot;textures/T_Speaker_32.png&quot;</span>,  <span class="stringliteral">&quot;textures/T_Speaker_16.png&quot;</span>,</div><div class="line">                                <span class="stringliteral">&quot;textures/T_Speaker_8.png&quot;</span>,   <span class="stringliteral">&quot;textures/T_Speaker_4.png&quot;</span>,   <span class="stringliteral">&quot;textures/T_Speaker_2.png&quot;</span>,</div><div class="line">                                <span class="stringliteral">&quot;textures/T_Speaker_1.png&quot;</span> };</div><div class="line">textures[0] = createMipmappedTextureFromAssets(pPaths);</div></div><!-- fragment --><h1><a class="anchor" id="mipmappingGeneratingMipmaps"></a>
Generating mipmaps in Vulkan</h1>
<p>We have seen the case in which we had already generated our mipmaps, but what if we only have a single image?</p>
<p>There is no built-in support for generating mip-maps in Vulkan, but we can use vkCmdBlitImage to achieve the same result. Here is an example, similar to the previous one, with generated mipmaps:</p>
<div class="image">
<img src="mipmapping_auto_generated.gif" alt="mipmapping_auto_generated.gif"/>
<div class="caption">
Automatically generated mipmaps</div></div>
<p> Given the code we have already written, we can implement mipmap generation just by changing a few things. Our function, createMipmappedTextureFromAssets, will now accept an optional parameter generateMipLevels: if true, mip levels will be generated from the first item in pPaths.</p>
<p>The first change is related to mipLevelCount, which must now be computed rather than obtained from the size of the input vector:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (generateMipLevels)</div><div class="line">{</div><div class="line">        <span class="comment">// Get the number of mip levels to be generated, based on the size of the source.</span></div><div class="line">        mipLevelCount = floor(log2(<span class="keywordtype">float</span>(min(mipLevels[0].width, mipLevels[0].height)))) + 1;</div><div class="line">}</div></div><!-- fragment --><p>The size of each mip level is obtained by cutting in half each dimension of the previous level, until one of the dimensions hits 1; thus the number of mip levels is the base 2 logarithm of the smaller dimension of the input image.</p>
<p>We will then need to add VK_IMAGE_USAGE_TRANSFER_SRC_BIT to the usage flags for the image, as we will use the image itself as a source to generate mipmaps.</p>
<div class="fragment"><div class="line">info.usage = (generateMipLevels ? VK_IMAGE_USAGE_TRANSFER_SRC_BIT : 0) | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;</div></div><!-- fragment --><p>We will generate each mip level by scaling the previous one in half. Before we can start, though, we need to load the first mip level to the image in the usual way:</p>
<div class="fragment"><div class="line">VkBufferImageCopy region = {};</div><div class="line">region.bufferOffset = 0;</div><div class="line">region.bufferRowLength = mipLevels[0].width;</div><div class="line">region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div><div class="line">region.imageSubresource.mipLevel = 0;</div><div class="line">region.imageSubresource.layerCount = 1;</div><div class="line">region.imageExtent.width = mipLevels[0].width;</div><div class="line">region.imageExtent.height = mipLevels[0].height;</div><div class="line">region.imageExtent.depth = 1;</div><div class="line"></div><div class="line"><span class="comment">// Copy the buffer for the first mip level to our optimally tiled image.</span></div><div class="line">vkCmdCopyBufferToImage(cmd, mipLevels[0].stagingBuffer.buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &amp;region);</div><div class="line"></div><div class="line"><span class="comment">// Transition first mip level into a TRANSFER_SRC_OPTIMAL layout.</span></div><div class="line"><span class="comment">// We need to wait for first CopyBuffer to complete before we can transition away from TRANSFER_DST_OPTIMAL,</span></div><div class="line"><span class="comment">// so use VK_PIPELINE_STAGE_TRANSFER_BIT as the srcStageMask.</span></div><div class="line">imageMemoryBarrier(cmd, image, VK_ACCESS_TRANSFER_WRITE_BIT, VK_ACCESS_TRANSFER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,</div><div class="line">                   VK_PIPELINE_STAGE_TRANSFER_BIT, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,</div><div class="line">                   0, 1);</div></div><!-- fragment --><p>Everything looks the same as before, apart from the last part: this is a critical step, as we won't be able to execute transfer commands unless the texture is in the appropriate layout. Specifically, we need to transition the first mip level from VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL to VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL; this way we will be able to use it as a source to generate the next level.</p>
<p>We will then loop through the mip levels and use vkCmdBlitImage to generate each level based on the previous one:</p>
<div class="fragment"><div class="line">VkImageBlit region = {};</div><div class="line">region.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div><div class="line">region.srcSubresource.mipLevel = i - 1;</div><div class="line">region.srcSubresource.layerCount = 1;</div><div class="line">region.srcOffsets[1].x = max(mipLevels[0].width &gt;&gt; (i - 1), 1u);</div><div class="line">region.srcOffsets[1].y = max(mipLevels[0].height &gt;&gt; (i - 1), 1u);</div><div class="line">region.srcOffsets[1].z = 1;</div><div class="line">region.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div><div class="line">region.dstSubresource.mipLevel = i;</div><div class="line">region.dstSubresource.layerCount = 1;</div><div class="line">region.dstOffsets[1].x = max(mipLevels[0].width &gt;&gt; i, 1u);</div><div class="line">region.dstOffsets[1].y = max(mipLevels[0].height &gt;&gt; i, 1u);</div><div class="line">region.dstOffsets[1].z = 1;</div><div class="line"></div><div class="line"><span class="comment">// Generate a mip level by copying and scaling the previous one.</span></div><div class="line">vkCmdBlitImage(cmd, image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &amp;region, VK_FILTER_LINEAR);</div></div><!-- fragment --><p>The x and y components of srcOffsets[1] and dstOffsets[1] correspond to the width and height of each mip level, which we can get by shifting the width and height of the base image. We also want to ensure that each dimension is greater or equal than 1.</p>
<p>This time we have dependencies between each iteration of the loop, as the previous blit must be complete before we can start the next one. In order to enforce this dependency, we will need to add memory barriers within the loop.</p>
<p>After the blit operation we will not need the previous mip level anymore, so we can transition it to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL. We also need to transition the current level to VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, so that it can be used as a source for the next iteration. In the last iteration, we can just transition the current level to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL.</p>
<div class="fragment"><div class="line"><span class="comment">// Transition the previous mip level into a SHADER_READ_ONLY_OPTIMAL layout.</span></div><div class="line">imageMemoryBarrier(cmd, image, VK_ACCESS_TRANSFER_READ_BIT, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,</div><div class="line">                   VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,</div><div class="line">                   i - 1, 1);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (i + 1 &lt; mipLevelCount)</div><div class="line">{</div><div class="line">        <span class="comment">// Transition the current mip level into a TRANSFER_SRC_OPTIMAL layout, to be used as the source for the next one.</span></div><div class="line">        imageMemoryBarrier(cmd, image, VK_ACCESS_TRANSFER_WRITE_BIT, VK_ACCESS_TRANSFER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,</div><div class="line">                           VK_PIPELINE_STAGE_TRANSFER_BIT, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,</div><div class="line">                           i, 1);</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">        <span class="comment">// If this is the last iteration of the loop, transition the mip level directly to a SHADER_READ_ONLY_OPTIMAL layout.</span></div><div class="line">        imageMemoryBarrier(cmd, image, VK_ACCESS_TRANSFER_WRITE_BIT, VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,</div><div class="line">                           VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,</div><div class="line">                           i, 1);</div><div class="line">}</div></div><!-- fragment --><p>Nothing else is required, so we can now load a texture and generate mipmaps for it:</p>
<div class="fragment"><div class="line">textures[1] = createMipmappedTextureFromAssets({ <span class="stringliteral">&quot;textures/T_Pedestal_512.png&quot;</span> }, <span class="keyword">true</span>);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2016</a>
    </li>
  </ul>
</div>
</body>
</html>
