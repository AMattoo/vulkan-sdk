<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Vulkan SDK for Android 1.1.1: Deferring shading with Multipass</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vulkan SDK for Android 1.1.1
<span id="malidevcenter"><a href="http://malideveloper.arm.com">Mali Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('multipass.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Deferring shading with Multipass </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Introduces Vulkan Multipass, which enables highly efficient deferred shading on Mali GPUs.</p>
<div class="image">
<img src="multipass_final.png" alt="multipass_final.png"/>
<div class="caption">
Deferred shading</div></div>
 <dl class="section note"><dt>Note</dt><dd>The source for this sample can be found in samples/multipass in the SDK.</dd></dl>
<h1><a class="anchor" id="multipassIntro"></a>
Introduction</h1>
<p>Multipass is a great Vulkan feature which enables developers to implement deferred shading efficiently on mobile GPUs.</p>
<p>Traditionally, deferred shading on mobile has not been feasible due to the very intense bandwidth requirements on writing out a full G-Buffer to memory and then being read back as textures in the lighting pass. Extensions like GL_EXT_shader_pixel_local_storage in GLES enabled developers to keep the G-Buffer on-tile to avoid this extra bandwidth requirements, but now, this is a standard feature in Vulkan, which means no vendor-specific code paths to enable on-tile rendering anymore.</p>
<h2><a class="anchor" id="multipassRenderPass"></a>
The Render Pass</h2>
<p>Multipass works by allowing a render pass to contain multiple subpasses. These subpasses can have dependencies between each other. Normally, this wouldn't be any different than having two render passes, but a very important difference here is that the dependency can be restricted to a per-pixel region. Using this scheme, this allows a tiled GPU like Mali to merge two or more subpasses into one render pass where the results from one subpass can be kept on-tile in-between the two subpasses.</p>
<p>Setting up the render pass is a bit more involved this time around. We will need 4 attachments:</p><ul>
<li>Light</li>
<li>Depth/Stencil</li>
<li>Albedo</li>
<li>Normals</li>
</ul>
<p>In a more fancy renderer, we would also have a fifth attachment for PBR parameters, but for this sample, we'll keep it simple. The first subpass, we will write out the G-Buffer and write to the depth/stencil buffer.</p>
<p>Here, we will set up 3 color attachments. </p><div class="fragment"><div class="line">VkAttachmentReference colorReferences[3] = {</div><div class="line">        { 0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }, <span class="comment">// Light, emissive materials write here!</span></div><div class="line">        { 2, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }, <span class="comment">// Albedo</span></div><div class="line">        { 3, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }, <span class="comment">// Normals</span></div><div class="line">};</div><div class="line">VkAttachmentReference depthReference = { 1, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL };</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Optimal G-Buffer size for color attachments on current Mali GPU is 128 bits per pixels. A HDR-enabled physically based renderer should lay out the G-Buffer as such. This fits neatly into 128 bits:<ul>
<li>Light: B10G11R11_UFLOAT_PACK32</li>
<li>Albedo: RGBA8</li>
<li>Normal: RGB10A2</li>
<li>PBR/Misc: RGBA8</li>
</ul>
</dd></dl>
<p>After rendering the first subpass, we have our G-Buffer. shaders/debug.frag is used to show this G-Buffer at a fixed interval.</p>
<div class="image">
<img src="multipass_gbuffer.png" alt="multipass_gbuffer.png"/>
<div class="caption">
G-Buffer output side-by-side (Albedo, Normal, Depth)</div></div>
<p> In the second subpass, we use the G-Buffer to accumulate light onto the light attachment. For this, we can use plain blending. Normally, this attachment would be VK_FORMAT_B10G11R11_UFLOAT_PACK32 to allow HDR rendering, but since we're just rendering directly to the backbuffer here, 8-bit UNORM will do.</p>
<p>In the second subpass, we have only one color attachment, but three input attachments. Input attachments can be considered "special" textures, where you can only read the texel at gl_FragCoord.xy. </p><div class="fragment"><div class="line">VkAttachmentReference inputReferences[3] = {</div><div class="line">        { 2, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL }, <span class="comment">// Position</span></div><div class="line">        { 1, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL }, <span class="comment">// Depth</span></div><div class="line">        { 3, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL }, <span class="comment">// Normal</span></div><div class="line">};</div></div><!-- fragment --><p>An important point to note here is that the depth texture now has the layout DEPTH_STENCIL_READ_ONLY_OPTIMAL. The reason here is that we need to perform read-only depth testing as well as reading it as an input attachment at the same time. To do this, the layout should be DEPTH_STENCIL_READ_ONLY_OPTIMAL. Inside a renderpass, Vulkan takes care of any layout transitions automatically, so we do not have to perform any layout transitions ourselves.</p>
<h3><a class="anchor" id="multipassDependency"></a>
The subpass dependency</h3>
<p>Between subpass 0 and 1, we will need to specify a dependency. As in the other samples, we also have an external subpass dependency which performs the layout transition from UNDEFINED for us automatically.</p>
<div class="fragment"><div class="line">subpassDependencies[1].srcSubpass = 0;</div><div class="line">subpassDependencies[1].dstSubpass = 1;</div><div class="line">subpassDependencies[1].srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT |</div><div class="line">                                                                          VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT |</div><div class="line">                                                                          VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;</div><div class="line">subpassDependencies[1].dstStageMask = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;</div><div class="line">subpassDependencies[1].srcAccessMask =</div><div class="line">        VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;</div><div class="line">subpassDependencies[1].dstAccessMask = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT;</div><div class="line">subpassDependencies[1].dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;</div></div><!-- fragment --><div class="image">
<img src="multipass_final.png" alt="multipass_final.png"/>
<div class="caption">
Result after second subpass</div></div>
 <h1><a class="anchor" id="Basic"></a>
Deferred Lighting Technique</h1>
<p>There are many techniques for how to render deferred efficiently, here we will use the traditional method of rendering bounding geometry of a light and use blending to accumulate light to the pixels which the bounding geometry touches. To reduce some false positives, we use depth testing to test one-way intersection. On tiled GPUs, blending has no bandwidth cost, only fill-rate, so this is a decent alternative. For simplicity, we use the same cube mesh to represent the bounding geometry of a point light.</p>
<p>For this particular case, we deliberately choose not to instance the light volumes. The rationale here is that if we aren't using instancing, we can make use of push constants to hold the per-light data, which removes some indirections in the fragment shader. This can be a quite significant performance improvement. However, this is a trade-off. If a large number of lights are used, the overhead of many draw calls will likely outweigh the advantages of push constants here. Here, we have 8 lights, which is perfectly reasonable to not instance.</p>
<h1><a class="anchor" id="multipassTransient"></a>
Using lazily allocated G-Buffer</h1>
<p>G-Buffer attachments only need to live on the tile, at no point do we need to access memory, so using VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT is important for:</p><ul>
<li>Depth/Stencil</li>
<li>Albedo</li>
<li>Normals</li>
</ul>
<p>By keeping Depth/Stencil, Albedo and Normals on-tile only, we can save a lot of bandwidth and memory. In this sample, only color needs to be written out to memory, while a typical deferred renderer would have to write Emissive + Depth/Stencil + Albedo + Normals as 4 textures, then, all this data would have to be read back again in the lighting pass, then finally, the final light image needs to be written back, so effectively, multipass can give us a (4x + 4x + 1x = 9x) bandwidth improvement over traditional MRT in this case!</p>
<h1><a class="anchor" id="multipassGBufferPipeline"></a>
The G-Buffer pipeline</h1>
<p>For the G-Buffer pipeline, the major difference between a regular forward-shaded pipeline and this is that we have 3 color attachments this time, so we will need one blend attachment for each. We just need to set the color write mask, not anything else.</p>
<p>Another thing we're doing is that we are setting stencil to 1 if geometry is rendered. The reason for this is that we want to avoid accumulating light against the background later. </p><div class="fragment"><div class="line">depthStencilInfo.stencilTestEnable = <span class="keyword">true</span>;</div><div class="line">depthStencilInfo.front.passOp = VK_STENCIL_OP_REPLACE;</div><div class="line">depthStencilInfo.front.failOp = VK_STENCIL_OP_KEEP;</div><div class="line">depthStencilInfo.front.depthFailOp = VK_STENCIL_OP_KEEP;</div><div class="line">depthStencilInfo.front.compareOp = VK_COMPARE_OP_ALWAYS;</div><div class="line">depthStencilInfo.front.compareMask = 0xff;</div><div class="line">depthStencilInfo.front.writeMask = 0xff;</div><div class="line">depthStencilInfo.front.reference = 1;</div><div class="line">depthStencilInfo.back = depthStencilInfo.front;</div></div><!-- fragment --><p>In the G-Buffer shader itself, we emit emissive, albedo and normals which will be stored on-chip.</p>
<div class="fragment"><div class="line">layout(location = 0) out vec4 outputs[3];</div><div class="line"></div><div class="line">layout(set = 0, binding = 0) uniform sampler2D tex;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">        vec3 albedo = texture(tex, vTexCoord).rgb;</div><div class="line"></div><div class="line">        <span class="comment">// Emissive. Make the ARM logo emissive blue.</span></div><div class="line">        vec3 graydiff = albedo - dot(albedo, vec3(0.29, 0.60, 0.11));</div><div class="line">        <span class="keywordtype">float</span> emissive = 3.0 * smoothstep(0.02, 0.1, dot(graydiff, graydiff));</div><div class="line">        outputs[0] = vec4(emissive * albedo, 1.0);</div><div class="line"></div><div class="line">        <span class="comment">// Albedo</span></div><div class="line">        outputs[1] = vec4(albedo, 1.0);</div><div class="line">        <span class="comment">// Normals, pack -1, +1 range to 0, 1.</span></div><div class="line">        outputs[2] = vec4(0.5 * normalize(vNormal) + 0.5, 1.0);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="multipassLightPipeline"></a>
The Lighting Pipeline</h1>
<p>The lighting pipeline needs to blend, so we enable additive blending. </p><div class="fragment"><div class="line">VkPipelineColorBlendAttachmentState colorBlendState = {};</div><div class="line">colorBlendState.blendEnable = <span class="keyword">true</span>;</div><div class="line">colorBlendState.colorWriteMask = 0xf;</div><div class="line">colorBlendState.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;</div><div class="line">colorBlendState.dstColorBlendFactor = VK_BLEND_FACTOR_ONE;</div><div class="line">colorBlendState.colorBlendOp = VK_BLEND_OP_ADD;</div><div class="line">colorBlendState.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;</div><div class="line">colorBlendState.dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE;</div><div class="line">colorBlendState.alphaBlendOp = VK_BLEND_OP_ADD;</div></div><!-- fragment --><p>For depth and stencil testing, we need to be careful and disable depth writes. We use stencil testing, to only create fragments where we rendered actual geometry. This way, we can avoid applying lights to the background. </p><div class="fragment"><div class="line">depthStencilInfo.depthTestEnable = <span class="keyword">true</span>;</div><div class="line">depthStencilInfo.depthWriteEnable = <span class="keyword">false</span>;</div><div class="line">depthStencilInfo.depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL;</div><div class="line">depthStencilInfo.depthBoundsTestEnable = <span class="keyword">false</span>;</div><div class="line">depthStencilInfo.stencilTestEnable = <span class="keyword">true</span>;</div><div class="line">depthStencilInfo.front.passOp = VK_STENCIL_OP_KEEP;</div><div class="line">depthStencilInfo.front.failOp = VK_STENCIL_OP_KEEP;</div><div class="line">depthStencilInfo.front.depthFailOp = VK_STENCIL_OP_KEEP;</div><div class="line">depthStencilInfo.front.compareOp = VK_COMPARE_OP_EQUAL;</div><div class="line">depthStencilInfo.front.compareMask = 0xff;</div><div class="line">depthStencilInfo.front.writeMask = 0x0;</div><div class="line">depthStencilInfo.front.reference = 1;</div><div class="line">depthStencilInfo.back = depthStencilInfo.front;</div></div><!-- fragment --><p>For cubes which don't intersect with the camera, we use the front face and test that the cube is infront of the geometry. For cubes which do intersect, use the back-face instead and invert the cull mode, we'll end up with two pipelines. </p><div class="fragment"><div class="line">depthStencilInfo.depthCompareOp = VK_COMPARE_OP_GREATER_OR_EQUAL;</div><div class="line">rasterizationStateInfo.cullMode = VK_CULL_MODE_FRONT_BIT;</div></div><!-- fragment --><h1><a class="anchor" id="multipassSubpassLoad"></a>
Reading Input Attachments in Vulkan GLSL</h1>
<p>To read our input attachments in GLSL, we use the Vulkan GLSL function subpassLoad().</p>
<div class="fragment"><div class="line">layout(input_attachment_index = 0, <span class="keyword">set</span> = 0, binding = 0) uniform mediump subpassInput albedo;</div><div class="line">layout(input_attachment_index = 1, set = 0, binding = 1) uniform highp subpassInput depth;</div><div class="line">layout(input_attachment_index = 2, set = 0, binding = 2) uniform mediump subpassInput normals;</div><div class="line"></div><div class="line"><span class="comment">// Load G-Buffer albedo from tile buffer.</span></div><div class="line">vec4 color = subpassLoad(albedo);</div><div class="line"></div><div class="line"><span class="comment">// Load depth from tile buffer and reconstruct world position.</span></div><div class="line">vec4 clip = vec4(gl_FragCoord.xy * registers.inv_resolution * 2.0 - 1.0, subpassLoad(depth).x, 1.0);</div><div class="line">highp vec4 world_w = registers.inv_view_proj * clip;</div><div class="line">highp vec3 world = world_w.xyz / world_w.w;</div><div class="line"></div><div class="line"><span class="comment">// Load normal from tile buffer.</span></div><div class="line">vec3 normal = 2.0 * subpassLoad(normals).xyz - 1.0;</div></div><!-- fragment --><h2><a class="anchor" id="multipassSubpassLoadDescriptorSet"></a>
Binding input attachments to descriptor sets</h2>
<p>Not all GPU architectures can read subpass attachments from tile, and for this reason we need to also bind our input attachments to a descriptor set so these implementations can read subpass attachments as regular textures.</p>
<dl class="section note"><dt>Note</dt><dd>Do not skip this on Mali either.</dd></dl>
<div class="fragment"><div class="line">writes[1].dstSet = descriptorSets[1];</div><div class="line">writes[1].dstBinding = 0;</div><div class="line">writes[1].descriptorCount = 1;</div><div class="line">writes[1].descriptorType = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;</div><div class="line">writes[1].pImageInfo = inputImageInfos;</div><div class="line"></div><div class="line">writes[2].dstSet = descriptorSets[1];</div><div class="line">writes[2].dstBinding = 1;</div><div class="line">writes[2].descriptorCount = 1;</div><div class="line">writes[2].descriptorType = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;</div><div class="line">writes[2].pImageInfo = &amp;inputImageInfos[1];</div><div class="line"></div><div class="line">writes[3].dstSet = descriptorSets[1];</div><div class="line">writes[3].dstBinding = 2;</div><div class="line">writes[3].descriptorCount = 1;</div><div class="line">writes[3].descriptorType = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;</div><div class="line">writes[3].pImageInfo = &amp;inputImageInfos[2];</div></div><!-- fragment --><h1><a class="anchor" id="multipassDebug"></a>
Nifty Debug Output</h1>
<p>At regular intervals, a debug view with albedo/depth/normals are displayed. Depending on where we are rendering on screen, read one of the input attachments.</p>
<div class="fragment"><div class="line">layout(input_attachment_index = 0, <span class="keyword">set</span> = 0, binding = 0) uniform mediump subpassInput albedo;</div><div class="line">layout(input_attachment_index = 1, set = 0, binding = 1) uniform highp subpassInput depth;</div><div class="line">layout(input_attachment_index = 2, set = 0, binding = 2) uniform mediump subpassInput normals;</div><div class="line"></div><div class="line">layout(push_constant, std430) uniform Registers</div><div class="line">{</div><div class="line">        mat4 inv_view_proj;</div><div class="line">        vec4 color;</div><div class="line">        vec4 position;</div><div class="line">        vec2 inv_resolution;</div><div class="line">} registers;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">        <span class="keywordtype">float</span> x = gl_FragCoord.x * registers.inv_resolution.x;</div><div class="line">        vec4 color;</div><div class="line">        <span class="keywordflow">if</span> (x &lt; 0.333)</div><div class="line">                color = vec4(subpassLoad(albedo).rgb, 1.0);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (x &lt; 0.666)</div><div class="line">                color = vec4(subpassLoad(normals).rgb, 1.0);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">                color = vec4(subpassLoad(depth).xxx, 1.0);</div><div class="line">        outLight = color;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="multipassMipmapping"></a>
Mipmapping</h1>
<p>While not multipass-related, the textures in this scene demand to be tri-linearly filtered. The mipmap is generated on-the-fly using vkCmdBlitImage. The sampler needs to set up a linear mipfilter and the VkImageView must contain all mip-levels in the image. The maxLod must also be set to not clamp the LOD while sampling.</p>
<div class="fragment"><div class="line"><span class="comment">// We can mip-map images in Vulkan using vkCmdBlitImage. There is no vkCmdGenerateMipmap or anything like that.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 1; i &lt; numLevels; i++)</div><div class="line">{</div><div class="line">        <span class="comment">// Set up a blit from previous mip-level to the next.</span></div><div class="line">        VkImageBlit region = {};</div><div class="line">        region.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div><div class="line">        region.srcSubresource.mipLevel = i - 1;</div><div class="line">        region.srcSubresource.baseArrayLayer = 0;</div><div class="line">        region.srcSubresource.layerCount = 1;</div><div class="line">        region.dstSubresource = region.srcSubresource;</div><div class="line">        region.dstSubresource.mipLevel = i;</div><div class="line">        region.srcOffsets[1] = { std::max(<span class="keywordtype">int</span>(width &gt;&gt; (i - 1)), 1), std::max(<span class="keywordtype">int</span>(height &gt;&gt; (i - 1)), 1), 1 };</div><div class="line">        region.dstOffsets[1] = { std::max(<span class="keywordtype">int</span>(width &gt;&gt; i), 1), std::max(<span class="keywordtype">int</span>(height &gt;&gt; i), 1), 1 };</div><div class="line"></div><div class="line">        vkCmdBlitImage(commandBuffer, textureImage.image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, textureImage.image,</div><div class="line">                                   VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &amp;region, VK_FILTER_LINEAR);</div><div class="line"></div><div class="line">        <span class="comment">// We&#39;re done transfering from this level now, transition it to SHADER_READ_ONLY.</span></div><div class="line">        imageMemoryBarrierLevel(commandBuffer, textureImage.image, i - 1, VK_ACCESS_TRANSFER_READ_BIT,</div><div class="line">                                                        VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,</div><div class="line">                                                        VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,</div><div class="line">                                                        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);</div><div class="line"></div><div class="line">        <span class="comment">// If this is the last level, we can transition directly to SHADER_READ_ONLY.</span></div><div class="line">        <span class="keywordflow">if</span> (i + 1 == numLevels)</div><div class="line">        {</div><div class="line">                imageMemoryBarrierLevel(commandBuffer, textureImage.image, i, VK_ACCESS_TRANSFER_WRITE_BIT,</div><div class="line">                                                                VK_ACCESS_SHADER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,</div><div class="line">                                                                VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</div><div class="line">                                                                VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">                imageMemoryBarrierLevel(commandBuffer, textureImage.image, i, VK_ACCESS_TRANSFER_WRITE_BIT,</div><div class="line">                                                                VK_ACCESS_TRANSFER_READ_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,</div><div class="line">                                                                VK_PIPELINE_STAGE_TRANSFER_BIT, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</div><div class="line">                                                                VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL);</div><div class="line">        }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="multipassRenderLoop"></a>
Render Loop with multiple subpasses</h1>
<p>In the render loop, we can use vkCmdNextSubpass to step from the first subpass to the next. Dependencies are automatically handled by Vulkan as it knows everything from VkRenderPassCreateInfo.</p>
<div class="fragment"><div class="line">vkCmdBeginRenderPass(commandBuffer, &amp;renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);</div><div class="line"><span class="comment">// ... Render to G-Buffer</span></div><div class="line">vkCmdNextSubpass(commandBuffer, VK_SUBPASS_CONTENTS_INLINE);</div><div class="line"><span class="comment">// ... Render lighting</span></div><div class="line">vkCmdEndRenderPass(commandBuffer);</div><div class="line"><span class="comment">// Done!</span></div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2016</a>
    </li>
  </ul>
</div>
</body>
</html>
