<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Mali Vulkan SDK for Android 1.1.0: Multisampling in Vulkan</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mali Vulkan SDK for Android 1.1.0
<span id="malidevcenter"><a href="http://malideveloper.arm.com">Mali Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('multisampling.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Multisampling in Vulkan </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document will give you an introduction to efficiently use multisampling in Vulkan.</p>
<div class="image">
<img src="multisampling.png" alt="multisampling.png"/>
<div class="caption">
Multisampling in Vulkan with resolve attachments</div></div>
 <div class="image">
<img src="rotating_texture.png" alt="rotating_texture.png"/>
<div class="caption">
Same quad, without multisampling</div></div>
 <dl class="section note"><dt>Note</dt><dd>The source for this sample can be found in samples/multisampling in the SDK.</dd></dl>
<h1><a class="anchor" id="multisamplingIntro"></a>
Introduction</h1>
<p>For this sample, we will look at how we can efficiently implement multisampled anti-aliasing (MSAA) on Mali GPUs the most efficient way. There are two main approaches we can choose from, where one alternative is dramatically better than the other.</p>
<p>We will base the sample on <a class="el" href="rotating_texture.html">Rotating Texture</a> so we can focus on the differences from rendering without MSAA to rendering with MSAA.</p>
<h2><a class="anchor" id="multisamplingSlowResolve"></a>
Rendering to Multisampled Texture, Resolving Later (slow)</h2>
<p>The traditional way of doing multisampling is to first create a multisampled texture, render to it, then have an explicit "resolve" step. This is highly inefficient. To implement this, the GPU needs to write out a full 4xMSAA buffer, which is four times the size of a regular texture, then read it back to the GPU in order to resolve the final pixel values.</p>
<div class="fragment"><div class="line"><span class="comment">// Resolves a multisampled image to non-multisampled, but extremely expensive.</span></div><div class="line">vkCmdResolveImage(cmd, srcImage, dstImage, ...);</div></div><!-- fragment --><p>It is highly recommended to avoid this path on Mali.</p>
<h2><a class="anchor" id="multisamplingResolveOnTile"></a>
Resolving a transient multisampled texture to non-multisampled texture (optimal)</h2>
<p>Vulkan exposes a fast path which takes full advantage of tiled architectures. On Mali, we can obtain 4xMSAA practically "free" (typically 1-2 % speed hit) by making use of resolve attachments in Vulkan.</p>
<h1><a class="anchor" id="multisamplingRenderPass"></a>
Setting up the VkRenderpass</h1>
<p>For multisampled rendering, we need to change how we set up our render pass. We will need two attachments, one multisampled texture, and one without.</p>
<div class="fragment"><div class="line">VkAttachmentDescription attachments[2] = { { 0 } };</div><div class="line"></div><div class="line"><span class="comment">// This is the multisampled attachment we will render to.</span></div><div class="line"><span class="comment">// After resolving the texture, we do not need to preserve it, so use DONT_CARE for storeOp here.</span></div><div class="line">attachments[0].format = format;</div><div class="line">attachments[0].samples = VK_SAMPLE_COUNT_4_BIT;</div><div class="line">attachments[0].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</div><div class="line"></div><div class="line"><span class="comment">// DONT_CARE is critical here, since it allows tile based renderers to completely avoid</span></div><div class="line"><span class="comment">// writing out the multisampled framebuffer to memory. This is a huge performance and bandwidth</span></div><div class="line"><span class="comment">// improvement.</span></div><div class="line">attachments[0].storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</div><div class="line"></div><div class="line">attachments[0].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</div><div class="line">attachments[0].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</div><div class="line"></div><div class="line"><span class="comment">// The image layout will be attachmentOptimal when we&#39;re executing the renderpass.</span></div><div class="line">attachments[0].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</div><div class="line">attachments[0].finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;</div><div class="line"></div><div class="line"><span class="comment">// This is the backbuffer which we will resolve the multisampled image to.</span></div><div class="line">attachments[1].format = format;</div><div class="line">attachments[1].samples = VK_SAMPLE_COUNT_1_BIT;</div><div class="line"><span class="comment">// loadOp is meaningless here since we will resolve to it and never render to it.</span></div><div class="line">attachments[1].loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</div><div class="line">attachments[1].storeOp = VK_ATTACHMENT_STORE_OP_STORE;</div><div class="line">attachments[1].stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</div><div class="line">attachments[1].stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</div><div class="line"></div><div class="line"><span class="comment">// The image layout will be attachmentOptimal when we&#39;re executing the renderpass.</span></div><div class="line">attachments[1].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</div><div class="line">attachments[1].finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;</div></div><!-- fragment --><p>It is critically important that we set up the storeOp correctly for the multisampled attachment. After resolve, there is no need why we should ever want to keep the multisampled data, so we set it to STORE_OP_DONT_CARE. This allows the driver to only keep the multisampled buffer on-tile instead of in main memory.</p>
<p>Now, we specify our subpass, we only have one subpass, but it will have two attachments. One color buffer, and one resolve buffer.</p>
<div class="fragment"><div class="line"><span class="comment">// We have one subpass.</span></div><div class="line"><span class="comment">// This subpass has 2 color attachments. First is multisampled, other is not.</span></div><div class="line">VkAttachmentReference colorRef = { 0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL };</div><div class="line">VkAttachmentReference resolveRef = { 1, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL };</div><div class="line">VkSubpassDescription subpass = { 0 };</div><div class="line">subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;</div><div class="line">subpass.colorAttachmentCount = 1;</div><div class="line"></div><div class="line"><span class="comment">// At end of sub-pass, resolve the multisampled color to backbuffer.</span></div><div class="line">subpass.pColorAttachments = &amp;colorRef;</div><div class="line">subpass.pResolveAttachments = &amp;resolveRef;</div><div class="line"></div><div class="line"><span class="comment">// Finally, create the renderpass.</span></div><div class="line">VkRenderPassCreateInfo rpInfo = { VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO };</div><div class="line">rpInfo.attachmentCount = 2;</div><div class="line">rpInfo.pAttachments = attachments;</div><div class="line">rpInfo.subpassCount = 1;</div><div class="line">rpInfo.pSubpasses = &amp;subpass;</div><div class="line">VK_CHECK(vkCreateRenderPass(pContext-&gt;getDevice(), &amp;rpInfo, <span class="keyword">nullptr</span>, &amp;renderPass));</div></div><!-- fragment --><h1><a class="anchor" id="multisamplingPipeline"></a>
Setting up the VkPipeline</h1>
<p>In the VkPipeline, there aren't many changes. We need to specify that we are rendering with 4x multisampling.</p>
<div class="fragment"><div class="line"><span class="comment">// Render with 4x MSAA.</span></div><div class="line">VkPipelineMultisampleStateCreateInfo multisample = { VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO };</div><div class="line">multisample.rasterizationSamples = VK_SAMPLE_COUNT_4_BIT;</div><div class="line">multisample.sampleShadingEnable = <span class="keyword">false</span>;</div><div class="line">multisample.alphaToCoverageEnable = <span class="keyword">false</span>;</div><div class="line">multisample.alphaToOneEnable = <span class="keyword">false</span>;</div></div><!-- fragment --><h1><a class="anchor" id="multisamplingFramebuffer"></a>
Setting up the VkFramebuffers</h1>
<p>When creating the framebuffers, we just have to include our multisampled texture. Note that multisampledRenderTarget comes first since we specified that attachment 0 was multisampled in VkRenderpass.</p>
<div class="fragment"><div class="line"><span class="comment">// Build the framebuffer.</span></div><div class="line">VkFramebufferCreateInfo fbInfo = { VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO };</div><div class="line">fbInfo.renderPass = renderPass;</div><div class="line">fbInfo.attachmentCount = 2;</div><div class="line"></div><div class="line"><span class="keyword">const</span> VkImageView attachments[] = { multisampledRenderTarget.view, backbuffer.view };</div><div class="line">fbInfo.pAttachments = attachments;</div><div class="line">fbInfo.width = width;</div><div class="line">fbInfo.height = height;</div><div class="line">fbInfo.layers = 1;</div><div class="line"></div><div class="line">VK_CHECK(vkCreateFramebuffer(device, &amp;fbInfo, <span class="keyword">nullptr</span>, &amp;backbuffer.framebuffer));</div></div><!-- fragment --><h1><a class="anchor" id="multisamplingTexture"></a>
Creating a Transient, Lazily Allocated Texture</h1>
<p>We know that we will never actually need to write to the multisampled texture. It will only live as a temporary entity while executing the render pass.</p>
<p>We can express this by using TRANSIENT_ATTACHMENT_BIT.</p>
<div class="fragment"><div class="line">VkImageCreateInfo info = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };</div><div class="line">info.imageType = VK_IMAGE_TYPE_2D;</div><div class="line">info.format = format;</div><div class="line">info.extent.width = width;</div><div class="line">info.extent.height = height;</div><div class="line">info.extent.depth = 1;</div><div class="line">info.mipLevels = 1;</div><div class="line">info.arrayLayers = 1;</div><div class="line">info.samples = VK_SAMPLE_COUNT_4_BIT;</div><div class="line">info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</div><div class="line">info.tiling = VK_IMAGE_TILING_OPTIMAL;</div><div class="line"></div><div class="line"><span class="comment">// This image will only be used as a transient render target.</span></div><div class="line"><span class="comment">// Its purpose is only to hold the multisampled data before resolving the render pass.</span></div><div class="line">info.usage = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT;</div><div class="line">info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</div><div class="line"></div><div class="line"><span class="comment">// Create texture.</span></div><div class="line">VkImage image;</div><div class="line">VkDeviceMemory memory;</div><div class="line">VK_CHECK(vkCreateImage(device, &amp;info, <span class="keyword">nullptr</span>, &amp;image));</div></div><!-- fragment --><p>When we allocate memory for this texture, we can choose a lazy allocation which only actually allocated memory for the texture when it's being written to (never).</p>
<div class="fragment"><div class="line">VkMemoryAllocateInfo alloc = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };</div><div class="line">alloc.allocationSize = memReqs.size;</div><div class="line"><span class="comment">// For multisampled attachments, we will want to use LAZILY allocated if such a type is available.</span></div><div class="line">alloc.memoryTypeIndex =</div><div class="line">        findMemoryTypeFromRequirementsWithFallback(memReqs.memoryTypeBits, VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT);</div><div class="line">VK_CHECK(vkAllocateMemory(device, &amp;alloc, <span class="keyword">nullptr</span>, &amp;memory));</div><div class="line">vkBindImageMemory(device, image, memory, 0);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2016</a>
    </li>
  </ul>
</div>
</body>
</html>
