<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Mali Vulkan SDK for Android 1.1.0: Multithreading in Vulkan</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mali Vulkan SDK for Android 1.1.0
<span id="malidevcenter"><a href="http://malideveloper.arm.com">Mali Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('multithreading.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Multithreading in Vulkan </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Shows you how to use Vulkan to draw a scene using multiple CPU threads.</p>
<div class="image">
<img src="multithreading.png" alt="multithreading.png"/>
<div class="caption">
Dispatching many draw calls over multiple threads</div></div>
 <dl class="section note"><dt>Note</dt><dd>The source for this sample can be found in samples/multithreading in the SDK.</dd></dl>
<h1><a class="anchor" id="multithreadingIntro"></a>
Introduction</h1>
<p>Multithreading is a cornerstone of Vulkan. Vulkan allows application to spread rendering workload across multiple CPU threads. This can have huge benefit for complex applications.</p>
<p>There is no longer any need for applications to do all rendering in a single rendering thread. The rendering thread can often be the bottleneck. By spreading out work across multiple threads, rendering work and complete early and the CPU can stay asleep for longer, conserving battery life. It is far better for power consumption that 4 CPU cores stay awake 25% of the time, than 1 core staying awake 100% of the time.</p>
<p>In this sample, we will see how we can split up rendering work across multiple threads. We base the sample on <a class="el" href="rotating_texture.html">Rotating Texture</a>, expanding it by rendering several textured quads, split over multiple threads and many draw calls.</p>
<h1><a class="anchor" id="multithreadingCommandBufferSafety"></a>
Rules for Safe Multithreading</h1>
<p>In Vulkan, most operations are externally synchronized, as in, it is up to the programmer to ensure that a resource is not written to simultaneously by multiple threads. This applies to command buffers as well. This means that multiple threads cannot efficiently build commands on the same command buffers. We need to split up the rendering workload into different command buffers.</p>
<p>However, we cannot just consider command buffers. Command buffers allocate their memory from command pools. Each worker thread must therefore own its own command pool. This way each worker thread can allocate command buffers from separate pool. This avoids all kind of locking and applications can build commands completely in parallel.</p>
<p>To make this setup convenient we will create a "thread pool" abstraction with a fixed number of threads available. We assign one command buffer manager per worker thread, where each command manager in turn contains one command pool per swapchain image. This way each thread can always build commands safely.</p>
<h1><a class="anchor" id="multithreadingSecondary"></a>
Secondary Command Buffers</h1>
<p>In Vulkan, a renderpass must begin and end in the same command buffer. We therefore cannot efficiently parallelize building of a <em>primary</em> command buffer. However, we can build part of a renderpass inside separate, <em>secondary</em> command buffers. The purpose of secondary command buffers is that they can focus solely on building draw commands on a separate thread, and the command buffer can be linked back into the primary command buffer by means of vkCmdExecuteCommands().</p>
<h1><a class="anchor" id="multithreadingRendering"></a>
Rendering</h1>
<p>From the <a class="el" href="rotating_texture.html">Rotating Texture</a> sample, we modify things slightly. We begin the renderpass by specifying that we will use SECONDARY_COMMAND_BUFFERS (and only that) for submitting work. We can now request secondary command buffers. It is essentially the same as requestPrimaryCommandBuffer, except that we also specify the worker thread ID, so we can allocate the command buffer from separate command pools.</p>
<div class="fragment"><div class="line">vkCmdBeginRenderPass(cmd, &amp;rpBegin, VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS);</div><div class="line"><span class="keywordtype">unsigned</span> numThreads = threadPool.getWorkerThreadCount();</div><div class="line">vector&lt;VkCommandBuffer&gt; commandBuffers(numThreads);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; numThreads; i++)</div><div class="line">{</div><div class="line">        VkCommandBuffer secondaryCmd = pContext-&gt;requestSecondaryCommandBuffer(i);</div><div class="line">        commandBuffers[i] = secondaryCmd;</div><div class="line"></div><div class="line">        ...</div><div class="line">}</div></div><!-- fragment --><p>When beginning the command buffer, we specify inheritance information, such as being able to create graphics commands. The state in the secondary command buffers are completely isolated, so we need to specify up front at least which render pass we will use. We also specify which framebuffer we are rendering into.</p>
<div class="fragment"><div class="line">VkCommandBufferBeginInfo secondaryBeginInfo = { VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO };</div><div class="line">VkCommandBufferInheritanceInfo inheritance = { VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO };</div><div class="line">secondaryBeginInfo.flags =</div><div class="line">        VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT | VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT;</div><div class="line">secondaryBeginInfo.pInheritanceInfo = &amp;inheritance;</div><div class="line">inheritance.renderPass = renderPass;</div><div class="line">inheritance.framebuffer = backbuffer.framebuffer;</div><div class="line">inheritance.subpass = 0;</div><div class="line"></div><div class="line">vkBeginCommandBuffer(secondaryCmd, &amp;secondaryBeginInfo);</div></div><!-- fragment --><p>We are now ready to push work into the thread pool.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> beginInstance = (i * NUM_INSTANCES) / numThreads;</div><div class="line"><span class="keywordtype">unsigned</span> endInstance = ((i + 1) * NUM_INSTANCES) / numThreads;</div><div class="line">VkDescriptorSet descriptorSet = frame.descriptorSet;</div><div class="line"></div><div class="line">threadPool.pushWorkToThread(i, [=]</div><div class="line">                            {</div><div class="line">                                renderScene(secondaryCmd, beginInstance, endInstance, descriptorSet);</div><div class="line">                            });</div></div><!-- fragment --><p>renderScene() is very similar to the main rendering function in <a class="el" href="rotating_texture.html">Rotating Texture</a>. The main difference is that we split up the scene into many draw calls.</p>
<div class="fragment"><div class="line">vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &amp;<span class="keyword">set</span>, 0, <span class="keyword">nullptr</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> baseInstance = beginInstance; baseInstance &lt; endInstance;)</div><div class="line">{</div><div class="line">        <span class="keywordtype">unsigned</span> instancesToDraw = glm::min(endInstance - baseInstance, <span class="keywordtype">unsigned</span>(MAX_INSTANCES_PER_DRAW_CALL));</div><div class="line">        vkCmdDraw(cmd, 4, instancesToDraw, 0, baseInstance);</div><div class="line">        baseInstance += instancesToDraw;</div><div class="line">}</div></div><!-- fragment --><p>In the main thread, we can now wait for the rendering threads to complete their work and inject the commands into the main render pass.</p>
<div class="fragment"><div class="line"><span class="comment">// Wait for thread pool to go idle.</span></div><div class="line">threadPool.waitIdle();</div><div class="line"></div><div class="line"><span class="comment">// Submit the secondary command buffers to the primary command buffer.</span></div><div class="line">vkCmdExecuteCommands(cmd, commandBuffers.size(), commandBuffers.data());</div><div class="line"></div><div class="line"><span class="comment">// Complete render pass.</span></div><div class="line">vkCmdEndRenderPass(cmd);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2016</a>
    </li>
  </ul>
</div>
</body>
</html>
