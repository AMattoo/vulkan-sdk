<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Vulkan SDK for Android 1.1.1: Rotating Texture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vulkan SDK for Android 1.1.1
<span id="malidevcenter"><a href="http://malideveloper.arm.com">Mali Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rotating_texture.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Rotating Texture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial introduces texturing and uniform buffers.</p>
<div class="image">
<img src="rotating_texture.png" alt="rotating_texture.png"/>
<div class="caption">
Rotating a quad with uniform buffers and textures</div></div>
 <dl class="section note"><dt>Note</dt><dd>The source for this sample can be found in samples/rotating_texture in the SDK.</dd></dl>
<h1><a class="anchor" id="rotatingTextureIntroduction"></a>
Introduction</h1>
<p>This sample builds on the <a class="el" href="hello_triangle.html">Hello Triangle</a> sample. We will add texturing as well as rotating the quad using a uniform buffer.</p>
<h1><a class="anchor" id="rotatingTextureDescriptorSets"></a>
Descriptor Sets</h1>
<p>For binding resources to the command buffers such as textures and uniform buffers, we will need to introduce descriptor sets.</p>
<p>In Vulkan, resources which are used by a pipeline are organized into descriptor sets. Descriptor sets are collections of buffers and images which can be accessed by the pipeline. One core idea of descriptor sets is that they are designed to be organized in terms of update frequency. For example, descriptor set #0 could have per-frame resources like shadow maps, MVP matrices, etc. Descriptor set #1 and beyond would progressively have higher and higher frequency data. Vulkan mandates support for at least 4 descriptor sets being used at the same time.</p>
<h1><a class="anchor" id="rotatingTextureUpload"></a>
Uploading Textures</h1>
<p>Uploading textures in Vulkan is a very explicit operation. We will need to create an image which is to be sampled, and a buffer which will hold the data to be copied over to the target texture.</p>
<p>First, we load the asset into a raw buffer.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> width, height;</div><div class="line">vector&lt;uint8_t&gt; buffer;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (FAILED(loadRgba8888TextureFromAsset(pPath, &amp;buffer, &amp;width, &amp;height)))</div><div class="line">{</div><div class="line">        LOGE(<span class="stringliteral">&quot;Failed to load texture from asset.\n&quot;</span>);</div><div class="line">        abort();</div><div class="line">}</div></div><!-- fragment --><p>We will now create a TRANSFER_SRC buffer which can use to copy the data into an image.</p>
<div class="fragment"><div class="line">Buffer stagingBuffer = createBuffer(buffer.data(), width * height * 4, VK_BUFFER_USAGE_TRANSFER_SRC_BIT);</div></div><!-- fragment --><p>Now, we will create an optimally tiled texture which we can sample from and transfer to.</p>
<div class="fragment"><div class="line"><span class="comment">// We will transition the actual texture into a proper layout before transfering any data, so leave it as undefined.</span></div><div class="line">VkImageCreateInfo info = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };</div><div class="line">info.imageType = VK_IMAGE_TYPE_2D;</div><div class="line">info.format = VK_FORMAT_R8G8B8A8_UNORM;</div><div class="line">info.extent.width = width;</div><div class="line">info.extent.height = height;</div><div class="line">info.extent.depth = 1;</div><div class="line">info.mipLevels = 1;</div><div class="line">info.arrayLayers = 1;</div><div class="line">info.samples = VK_SAMPLE_COUNT_1_BIT;</div><div class="line">info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</div><div class="line">info.tiling = VK_IMAGE_TILING_OPTIMAL;</div><div class="line">info.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;</div><div class="line">info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</div><div class="line"></div><div class="line"><span class="comment">// Create texture.</span></div><div class="line">VK_CHECK(vkCreateImage(device, &amp;info, <span class="keyword">nullptr</span>, &amp;image));</div></div><!-- fragment --><p>As before, we will allocate DEVICE_LOCAL memory for the texture. We create a VkImageView from it as well. It is important that you bind memory to the image before creating a VkImageView.</p>
<p>We now copy the texture data from the staging buffer we created earlier into the texture. Copying is a command, so we will need a fresh command buffer.</p>
<div class="fragment"><div class="line">VkCommandBuffer cmd = pContext-&gt;requestPrimaryCommandBuffer();</div></div><!-- fragment --><p>We now need to transition our texture to a TRANSFER_DST_OPTIMAL layout from an UNDEFINED layout, and finally, we can copy the buffer to the texture.</p>
<div class="fragment"><div class="line">VkBufferImageCopy region;</div><div class="line">memset(&amp;region, 0, <span class="keyword">sizeof</span>(region));</div><div class="line">region.bufferOffset = 0;</div><div class="line">region.bufferRowLength = width;</div><div class="line">region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div><div class="line">region.imageSubresource.layerCount = 1;</div><div class="line">region.imageExtent.width = width;</div><div class="line">region.imageExtent.height = height;</div><div class="line">region.imageExtent.depth = 1;</div><div class="line"></div><div class="line"><span class="comment">// Copy the buffer to our optimally tiled image.</span></div><div class="line">vkCmdCopyBufferToImage(cmd, stagingBuffer.buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &amp;region);</div></div><!-- fragment --><p>After copying completes, we need to transition the texture from TRANSFER_DST_OPTIMAL into SHADER_READ_ONLY_OPTIMAL. The texture is now ready to be sampled from in a shader.</p>
<p>At the very end, we create a sampler object. This sampler specifies how we will sample our texture. We set up a simple bilinear filter.</p>
<div class="fragment"><div class="line"><span class="comment">// Finally, create a sampler.</span></div><div class="line">VkSamplerCreateInfo samplerInfo = { VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO };</div><div class="line">samplerInfo.magFilter = VK_FILTER_LINEAR;</div><div class="line">samplerInfo.minFilter = VK_FILTER_LINEAR;</div><div class="line">samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;</div><div class="line">samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;</div><div class="line">samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;</div><div class="line">samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;</div><div class="line">samplerInfo.mipLodBias = 0.0f;</div><div class="line">samplerInfo.maxAnisotropy = 1.0f;</div><div class="line">samplerInfo.compareEnable = <span class="keyword">false</span>;</div><div class="line">samplerInfo.minLod = 0.0f;</div><div class="line">samplerInfo.maxLod = 0.0f;</div><div class="line"></div><div class="line">VkSampler sampler;</div><div class="line">VK_CHECK(vkCreateSampler(device, &amp;samplerInfo, <span class="keyword">nullptr</span>, &amp;sampler));</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In Vulkan, it is possible to create textures with VK_IMAGE_TILING_LINEAR, this allows textures to be sampled without having to go through an explicit copy operation as you can memcpy() your texture data straight into the texture. This can be very useful for use cases where the texture is streamed in every frame. On Mali and other integrated GPUs this can save a lot of extra overhead if your application is doing a lot of dynamic 2D content. Not all GPUs are required to support this feature however, so you should check that this feature is available before making use of it.</dd></dl>
<h1><a class="anchor" id="rotatingTextureImageBarrier"></a>
Using Image Memory Barriers to Change Layouts</h1>
<p>In this sample and <a class="el" href="hello_triangle.html">Hello Triangle</a> we used the render pass to perform image layout transitions. In the case of uploading textures however, we need to perform layout transitions outside the render pass structure.</p>
<p>After creating the image, it is in an undefined layout and it will contain garbage data. To be able to transfer to the image, we need to use a layout which supports this. In this case we use TRANSFER_DST_OPTIMAL.</p>
<div class="fragment"><div class="line"><span class="comment">// Transition the uninitialized texture into a TRANSFER_DST_OPTIMAL layout.</span></div><div class="line"><span class="comment">// We do not need to wait for anything to make the transition, so use TOP_OF_PIPE_BIT as the srcStageMask.</span></div><div class="line">imageMemoryBarrier(cmd, image, 0, VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,</div><div class="line">                                   VK_PIPELINE_STAGE_TRANSFER_BIT, VK_IMAGE_LAYOUT_UNDEFINED,</div><div class="line">                                   VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> RotatingTexture::imageMemoryBarrier(VkCommandBuffer cmd, VkImage image, VkAccessFlags srcAccessMask,</div><div class="line">                                         VkAccessFlags dstAccessMask, VkPipelineStageFlags srcStageMask,</div><div class="line">                                         VkPipelineStageFlags dstStageMask, VkImageLayout oldLayout,</div><div class="line">                                         VkImageLayout newLayout)</div><div class="line">{</div><div class="line">        VkImageMemoryBarrier barrier = { VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER };</div><div class="line"></div><div class="line">        barrier.srcAccessMask = srcAccessMask;</div><div class="line">        barrier.dstAccessMask = dstAccessMask;</div><div class="line">        barrier.oldLayout = oldLayout;</div><div class="line">        barrier.newLayout = newLayout;</div><div class="line">        barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;</div><div class="line">        barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;</div><div class="line">        barrier.image = image;</div><div class="line">        barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</div><div class="line">        barrier.subresourceRange.levelCount = 1;</div><div class="line">        barrier.subresourceRange.layerCount = 1;</div><div class="line"></div><div class="line">        vkCmdPipelineBarrier(cmd, srcStageMask, dstStageMask, <span class="keyword">false</span>, 0, <span class="keyword">nullptr</span>, 0, <span class="keyword">nullptr</span>, 1, &amp;barrier);</div><div class="line">}</div></div><!-- fragment --><p>The structure of the pipeline barrier is that we wait for the pipeline stages that come before the barrier in srcStageMask, and when those pipeline stages complete, we unblock the pipeline stages in dstStageMask.</p>
<p>Between completing execution in srcStageMask and starting execution in dstStageMask, we can add memory barriers. This is where we can perform image layout transitions.</p>
<p>In our particular scenario here, we have a freshly allocated image. Nothing has written to the image prior to this. We can therefore transition right away. To avoid waiting for any pipeline stage, TOP_OF_PIPE_BIT can be used in the srcStageMask. We only care about the layout transition completing when we are copying to the image. This happens in the TRANSFER_BIT stage, so we make that our dstStageMask. While in the TRANSFER_BIT stage, our memory access is a TRANSFER_WRITE_BIT, so we add that to our dstAccessMask. It is important that stage masks and access masks match up (transfer access in transfer stages). In the Vulkan model, each pipeline stage can have its own caching and memory mechanisms.</p>
<p>After completing the transfer, we need to transition away from the TRANSFER_DST_OPTIMAL layout. An ideal choice here is SHADER_READ_ONLY_OPTIMAL.</p>
<div class="fragment"><div class="line"><span class="comment">// Wait for all transfers to complete before we let any fragment shading begin.</span></div><div class="line">imageMemoryBarrier(cmd, image, VK_ACCESS_TRANSFER_WRITE_BIT, VK_ACCESS_SHADER_READ_BIT,</div><div class="line">                                   VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,</div><div class="line">                                   VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);</div></div><!-- fragment --><p>We want to wait for all transfers to complete (srcStageMask), and all memory transfers to complete (srcAccessMask = TRANSFER_WRITE_BIT), before we transition from TRANSFER_DST_OPTIMAL to SHADER_READ_ONLY_OPTIMAL. In FRAGMENT_SHADER_BIT stage (dstStageMask), we will read the texture (dstAccessMask = SHADER_READ_BIT), so make sure that the fragment shader stage can observe the updated memory.</p>
<p>Another way to look at this is if we treat srcAccessMask as cache flush and dstAccessMask as cache invalidation.</p>
<h1><a class="anchor" id="rotatingTexturePipelineLayout"></a>
Creating a Pipeline Layout</h1>
<p>If we are using resources like buffers and textures in our shaders, we need to specify up-front a pipeline layout. This layout serves as the "signature" of the pipeline, effectively a function prototype which specifies where and which resources will be bound to our pipeline.</p>
<p>In this sample, we use a uniform buffer in the vertex shader, and a combined image sampler in the texture.</p>
<div class="fragment"><div class="line"><span class="comment">// shaders/textured.vert</span></div><div class="line">layout(<span class="keyword">set</span> = 0, binding = 1, std140) uniform UBO</div><div class="line">{</div><div class="line">    mat4 MVP;</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// shaders/textures.frag</span></div><div class="line">layout(<span class="keyword">set</span> = 0, binding = 0) uniform sampler2D sTexture;</div></div><!-- fragment --><p>We specify how descriptor set #0 is laid out. The first binding is a combined image sampler visible to fragment shaders, and the second binding is a uniform buffer, only visible to vertex shaders. Based on the single descriptor set layout, we create a pipeline layout.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RotatingTexture::initPipelineLayout()</div><div class="line">{</div><div class="line">        VkDevice device = pContext-&gt;getDevice();</div><div class="line"></div><div class="line">        VkDescriptorSetLayoutBinding bindings[2] = { { 0 } };</div><div class="line">        bindings[0].binding = 0;</div><div class="line">        bindings[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</div><div class="line">        bindings[0].descriptorCount = 1;</div><div class="line">        bindings[0].stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;</div><div class="line"></div><div class="line">        bindings[1].binding = 1;</div><div class="line">        bindings[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</div><div class="line">        bindings[1].descriptorCount = 1;</div><div class="line">        bindings[1].stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</div><div class="line"></div><div class="line">        VkDescriptorSetLayoutCreateInfo info = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO };</div><div class="line">        info.bindingCount = 2;</div><div class="line">        info.pBindings = bindings;</div><div class="line">        VK_CHECK(vkCreateDescriptorSetLayout(device, &amp;info, <span class="keyword">nullptr</span>, &amp;setLayout));</div><div class="line"></div><div class="line">        VkPipelineLayoutCreateInfo layoutInfo = { VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO };</div><div class="line">        layoutInfo.setLayoutCount = 1;</div><div class="line">        layoutInfo.pSetLayouts = &amp;setLayout;</div><div class="line">        VK_CHECK(vkCreatePipelineLayout(device, &amp;layoutInfo, <span class="keyword">nullptr</span>, &amp;pipelineLayout));</div><div class="line">}</div></div><!-- fragment --><p>When we create a pipeline, we also specify our pipeline layout.</p>
<div class="fragment"><div class="line">VkGraphicsPipelineCreateInfo pipe = { VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO };</div><div class="line">...</div><div class="line">pipe.layout = pipelineLayout;</div><div class="line">VK_CHECK(vkCreateGraphicsPipelines(device, pipelineCache, 1, &amp;pipe, <span class="keyword">nullptr</span>, &amp;pipeline));</div></div><!-- fragment --><h1><a class="anchor" id="rotatingTextureDescriptorPool"></a>
Creating a Descriptor Pool and Descriptor Sets</h1>
<p>Once we have our layout, we need to allocate and configure our descriptor sets, passing concrete textures and uniforms to our shader.</p>
<p>Descriptor sets require memory to allocate. Since descriptors by nature are highly vendor specific and opaque, descriptor set memory is allocated from pre-allocated pools. We create one by specifing which descriptors we will allocate from it.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> VkDescriptorPoolSize poolSizes[2] = {</div><div class="line">        { VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1 }, { VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1 },</div><div class="line">};</div><div class="line"></div><div class="line">VkDescriptorPoolCreateInfo poolInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO };</div><div class="line">poolInfo.poolSizeCount = 2;</div><div class="line">poolInfo.pPoolSizes = poolSizes;</div><div class="line">poolInfo.maxSets = 1;</div><div class="line">VK_CHECK(vkCreateDescriptorPool(device, &amp;poolInfo, <span class="keyword">nullptr</span>, &amp;frame.descriptorPool));</div><div class="line"></div><div class="line">VkDescriptorSetAllocateInfo allocInfo = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO };</div><div class="line">allocInfo.descriptorPool = frame.descriptorPool;</div><div class="line">allocInfo.descriptorSetCount = 1;</div><div class="line">allocInfo.pSetLayouts = &amp;setLayout;</div><div class="line">VK_CHECK(vkAllocateDescriptorSets(device, &amp;allocInfo, &amp;frame.descriptorSet));</div></div><!-- fragment --><p>When we allocate from a descriptor pool, we also specify the actual descriptor set layout we will use. In poolInfo.maxSets = 1 we specified that we can allocate one set from this pool. In a realistic application, this will likely be larger so we can amortize the creation of descriptor pools.</p>
<p>Once we have allocated a descriptor set, we update it by filling in real data.</p>
<div class="fragment"><div class="line">VkDescriptorBufferInfo bufferInfo = { frame.uniformBuffer.buffer, 0, <span class="keyword">sizeof</span>(mat4) };</div><div class="line">VkDescriptorImageInfo imageInfo = { texture.sampler, texture.view, texture.layout };</div><div class="line"></div><div class="line">writes[0].dstSet = frame.descriptorSet;</div><div class="line">writes[0].dstBinding = 0;</div><div class="line">writes[0].descriptorCount = 1;</div><div class="line">writes[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</div><div class="line">writes[0].pImageInfo = &amp;imageInfo;</div><div class="line"></div><div class="line">writes[1].dstSet = frame.descriptorSet;</div><div class="line">writes[1].dstBinding = 1;</div><div class="line">writes[1].descriptorCount = 1;</div><div class="line">writes[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</div><div class="line">writes[1].pBufferInfo = &amp;bufferInfo;</div><div class="line"></div><div class="line">vkUpdateDescriptorSets(device, 2, writes, 0, <span class="keyword">nullptr</span>);</div></div><!-- fragment --><p>We create one descriptor set here for every swapchain image. This is so we can update our UBOs while the GPU is busy rendering previous frames.</p>
<h1><a class="anchor" id="rotatingTextureRender"></a>
Rendering</h1>
<p>The rendering function is very similar to before <a class="el" href="hello_triangle.html">Hello Triangle</a>, except that we now update a UBO every frame and we bind a descriptor set.</p>
<div class="fragment"><div class="line">PerFrame &amp;frame = perFrame[swapchainIndex];</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// Bind the descriptor set.</span></div><div class="line">vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &amp;frame.descriptorSet, 0,</div><div class="line">                                                <span class="keyword">nullptr</span>);</div><div class="line"></div><div class="line"><span class="comment">// Update the uniform buffers memory.</span></div><div class="line">mat4 *pMatrix = <span class="keyword">nullptr</span>;</div><div class="line">VK_CHECK(vkMapMemory(pContext-&gt;getDevice(), frame.uniformBuffer.memory, 0, <span class="keyword">sizeof</span>(mat4), 0,</div><div class="line">                                         reinterpret_cast&lt;void **&gt;(&amp;pMatrix)));</div><div class="line"></div><div class="line"><span class="keywordtype">float</span> aspect = float(width) / height;</div><div class="line"><span class="keywordtype">float</span> textureAspect = float(texture.width) / texture.height;</div><div class="line"></div><div class="line"><span class="comment">// Simple orthographic projection.</span></div><div class="line">mat4 proj = ortho(aspect * -1.0f, aspect * 1.0f, -1.0f, 1.0f, 0.0f, 1.0f);</div><div class="line"></div><div class="line"><span class="comment">// Create a simple rotation matrix which rotates around the Z axis</span></div><div class="line"><span class="comment">// and write it to the mapped memory.</span></div><div class="line">accumulatedTime += deltaTime;</div><div class="line">mat4 rotation = rotate(accumulatedTime, vec3(0.0f, 0.0f, 1.0f));</div><div class="line"></div><div class="line"><span class="comment">// Scale the quad such that it matches the aspect ratio of our texture.</span></div><div class="line">mat4 model = scale(rotation, vec3(textureAspect, 1.0f, 1.0f));</div><div class="line"></div><div class="line"><span class="comment">// Fixup the projection matrix so it matches what Vulkan expects.</span></div><div class="line">*pMatrix = vulkanStyleProjection(proj) * model;</div><div class="line">vkUnmapMemory(pContext-&gt;getDevice(), frame.uniformBuffer.memory);</div><div class="line"></div><div class="line"><span class="comment">// Draw a quad with one instance.</span></div><div class="line">vkCmdDraw(cmd, 4, 1, 0, 0);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2016</a>
    </li>
  </ul>
</div>
</body>
</html>
