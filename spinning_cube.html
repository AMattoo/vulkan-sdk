<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Mali Vulkan SDK for Android 1.1.0: Spinning Cube with Depth Testing and Push Constants</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()
{ (i[r].q=i[r].q||[]).push(arguments)}
,i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-35797182-1', 'auto');
ga('send', 'pageview');
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="top_banner.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Mali Vulkan SDK for Android 1.1.0
<span id="malidevcenter"><a href="http://malideveloper.arm.com">Mali Developer Center</a></span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('spinning_cube.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Spinning Cube with Depth Testing and Push Constants </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial introduces depth testing and push constants</p>
<div class="image">
<img src="spinning_cube.png" alt="spinning_cube.png"/>
<div class="caption">
Spinning cube!</div></div>
 <dl class="section note"><dt>Note</dt><dd>The source for this sample can be found in samples/spinning_cube in the SDK.</dd></dl>
<h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>This sample builds on the <a class="el" href="rotating_texture.html">Rotating Texture</a> sample. We will illustrate the use of push constants and how to setup the various Vulkan objects to enable depth testing.</p>
<h1><a class="anchor" id="spinning_cube_pushc"></a>
Push constants</h1>
<p>Push constants represent a high speed path to modify uniform data. As opposed to uniform buffers push constants (in many implementations) offer higher performance access but they are of limited size. According to the spec the implementations should support at least 128 bytes of push constant data for all shader stages.</p>
<h2><a class="anchor" id="spinning_cube_pushc_glsl"></a>
Push constants in GLSL</h2>
<p>To enable push constants you will require changes in the shaders and some additional setup in the pipeline layout.</p>
<p>To define a number of uniforms as push constants we just need to add <b>push_constant</b> to the layout decoration. For example, to define the MVP matrix as push constant in a vertex shader:</p>
<div class="fragment"><div class="line">layout(std430, push_constant) uniform PushConstants</div><div class="line">{</div><div class="line">    mat4 MVP;</div><div class="line">} constants;</div><div class="line"></div><div class="line">...</div><div class="line">gl_Position = constants.MVP * vec4(Position, 1.0);</div></div><!-- fragment --><h2><a class="anchor" id="spinning_cube_pushc_pplinel"></a>
Creating a pipeline layout with push constant support</h2>
<p>The additions to the pipeline layout creation (for the above example) could be:</p>
<div class="fragment"><div class="line">VkPipelineLayoutCreateInfo layoutInfo;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// Setup the push constants. It&#39;s a single mat4 in the vertex shader.</span></div><div class="line">VkPushConstantRange pushConstantInfo = { 0 };</div><div class="line">pushConstantInfo.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</div><div class="line">pushConstantInfo.offset = 0;</div><div class="line">pushConstantInfo.size = <span class="keyword">sizeof</span>(mat4);</div><div class="line"></div><div class="line">layoutInfo.pushConstantRangeCount = 1;</div><div class="line">layoutInfo.pPushConstantRanges = &amp;pushConstantInfo;</div></div><!-- fragment --><p>In this example we define a single push constant range with the size of our MVP matrix. We also denote that our range will visible to the vertex shader. Some implementations will use the <em>stageFlags</em> to perform optimizations.</p>
<h2><a class="anchor" id="spinning_cube_pushc_update"></a>
Updating push constants</h2>
<p>Unlike uniform buffers, push constants are not part of descriptor sets. To update them you will only need to call vkCmdPushConstants() with the data you need to assign.</p>
<p>To update the push constant with a user provided matrix:</p>
<div class="fragment"><div class="line">mat4 matrix = ...;</div><div class="line">vkCmdPushConstants(cmd, pipelineLayout, VK_SHADER_STAGE_VERTEX_BIT, 0, <span class="keyword">sizeof</span>(matrix), &amp;matrix);</div></div><!-- fragment --><h1><a class="anchor" id="spinning_cube_depth"></a>
Depth testing</h1>
<p>Depth testing is an essential operation in 3D content. To enable it you will require a depth buffer, modifications to the graphics pipeline creation and modifications to the framebuffer and render pass.</p>
<h2><a class="anchor" id="spinning_cube_depth_buff"></a>
Creating the depth buffer</h2>
<p>To create the depth buffer we basically need a VkImageView, a VkImage and some VkDeviceMemory to back it up.</p>
<p>Just like in the <a class="el" href="multisampling.html">Multisampling in Vulkan</a> tutorial we will use a transient VkImage with lazily allocated memory for our depth buffer. It is recommended to use lazily allocated memory in order to save memory on those implementations that support it.</p>
<p>Of course there are some conditions that have to be met in order to skip the memory allocation. In this particular case the depth buffer will be cleared at the beginning of a subpass and discarded at the end of it. These conditions allow Mali GPUs to use the on-chip tile buffer for the depth tests without the need to back it with device memory.</p>
<p>The first thing is to create the VkImage with VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> VkFormat depthBufferFormat = VK_FORMAT_D16_UNORM;</div><div class="line"></div><div class="line">VkImageCreateInfo imageInfo = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };</div><div class="line">imageInfo.imageType = VK_IMAGE_TYPE_2D;</div><div class="line">imageInfo.format = depthBufferFormat;</div><div class="line">imageInfo.extent.width = width;</div><div class="line">imageInfo.extent.height = height;</div><div class="line">imageInfo.extent.depth = 1;</div><div class="line">imageInfo.mipLevels = 1;</div><div class="line">imageInfo.arrayLayers = 1;</div><div class="line">imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;</div><div class="line">imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</div><div class="line">imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;</div><div class="line">imageInfo.usage = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT;</div><div class="line">imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</div><div class="line"></div><div class="line">VK_CHECK(vkCreateImage(device, &amp;imageInfo, <span class="keyword">nullptr</span>, &amp;depthBufferImage));</div></div><!-- fragment --><p>Next, we will try to find the best memory type for our depth image.</p>
<div class="fragment"><div class="line">VkMemoryRequirements memoryRequirements = { 0 };</div><div class="line">vkGetImageMemoryRequirements(device, depthBufferImage, &amp;memoryRequirements);</div><div class="line">uint32_t memoryTypeIndex = findMemoryTypeFromRequirementsWithFallback(memoryRequirements.memoryTypeBits,</div><div class="line">                                                                      VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT);</div></div><!-- fragment --><p>Note that some implementations may not support lazily allocated memory which is why we need a fallback just in case.</p>
<p>Next, we actually allocate and bind the memory to the image.</p>
<div class="fragment"><div class="line">VkMemoryAllocateInfo memInfo = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };</div><div class="line">memInfo.allocationSize = memoryRequirements.size;</div><div class="line">memInfo.memoryTypeIndex = memoryTypeIndex;</div><div class="line"></div><div class="line">VK_CHECK(vkAllocateMemory(device, &amp;memInfo, <span class="keyword">nullptr</span>, &amp;depthBufferMemory));</div><div class="line"></div><div class="line">VK_CHECK(</div><div class="line">        vkBindImageMemory(device, depthBufferImage, depthBufferMemory, 0));</div></div><!-- fragment --><p>The last object that needs to be created is the depth VkImageView and its creation is similar to previous tutorials.</p>
<div class="fragment"><div class="line">VkImageViewCreateInfo viewInfo = { VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO };</div><div class="line">viewInfo.image = depthBufferImage;</div><div class="line">viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;</div><div class="line">viewInfo.format = depthBufferFormat;</div><div class="line">viewInfo.components.r = VK_COMPONENT_SWIZZLE_R;</div><div class="line">viewInfo.components.g = VK_COMPONENT_SWIZZLE_G;</div><div class="line">viewInfo.components.b = VK_COMPONENT_SWIZZLE_B;</div><div class="line">viewInfo.components.a = VK_COMPONENT_SWIZZLE_A;</div><div class="line">viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;</div><div class="line">viewInfo.subresourceRange.levelCount = 1;</div><div class="line">viewInfo.subresourceRange.layerCount = 1;</div><div class="line"></div><div class="line">VK_CHECK(vkCreateImageView(device, &amp;viewInfo, <span class="keyword">nullptr</span>, &amp;depthBufferView));</div></div><!-- fragment --><h2><a class="anchor" id="spinning_cube_depth_fb"></a>
Creating the framebuffer</h2>
<p>Now that we have the depth image view we need to add it as an attachment to our framebuffer.</p>
<div class="fragment"><div class="line">VkImageView attachments[2] = {backbuffer.view, depthBufferView};</div><div class="line">VkFramebufferCreateInfo fbInfo = { VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO };</div><div class="line">fbInfo.renderPass = renderPass;</div><div class="line">fbInfo.attachmentCount = 2;</div><div class="line">fbInfo.pAttachments = attachments;</div><div class="line">fbInfo.width = width;</div><div class="line">fbInfo.height = height;</div><div class="line">fbInfo.layers = 1;</div><div class="line"></div><div class="line">VK_CHECK(vkCreateFramebuffer(device, &amp;fbInfo, <span class="keyword">nullptr</span>, &amp;backbuffer.framebuffer));</div></div><!-- fragment --><p>The <em>backbuffer.view</em> is our color buffer and the <em>depthBufferView</em> is the depth image view created in <a class="el" href="spinning_cube.html#spinning_cube_depth_buff">Creating the depth buffer</a>.</p>
<h2><a class="anchor" id="spinning_cube_depth_rp"></a>
Creating the render pass</h2>
<p>Just like the creation of the VkFramebuffer, the VkRenderPass will have to become aware of the depth buffer's existence.</p>
<p>The first thing that needs to happen is to define two attachment descriptions, one for the color buffer and the second one for the depth buffer.</p>
<div class="fragment"><div class="line">VkAttachmentDescription attachments[2] = { 0 };</div><div class="line"></div><div class="line"><span class="comment">// Setup the color attachment.</span></div><div class="line">attachments[0].format = ...;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// Setup the depth attachment.</span></div><div class="line">attachments[1].format = depthBufferFormat;</div><div class="line">attachments[1].loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</div><div class="line">attachments[1].storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</div><div class="line">attachments[1].initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</div><div class="line">attachments[1].finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;</div><div class="line">...</div></div><!-- fragment --><p>The subpass description of our single subpass will have to be informed about the depth buffer.</p>
<div class="fragment"><div class="line">VkAttachmentReference colorRef = { 0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL };</div><div class="line">VkAttachmentReference depthRef = { 1, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL };</div><div class="line">VkSubpassDescription subpass = { 0 };</div><div class="line">subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;</div><div class="line">subpass.colorAttachmentCount = 1;</div><div class="line">subpass.pColorAttachments = &amp;colorRef;</div><div class="line">subpass.pDepthStencilAttachment = &amp;depthRef;</div></div><!-- fragment --><p>The rest of the render pass initialization is similar to <a class="el" href="rotating_texture.html">Rotating Texture</a> tutorial, we only need to include both of the attachments.</p>
<div class="fragment"><div class="line">VkRenderPassCreateInfo rpInfo = { VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO };</div><div class="line">rpInfo.attachmentCount = 2;</div><div class="line">rpInfo.pAttachments = attachments;</div><div class="line">rpInfo...</div></div><!-- fragment --><h2><a class="anchor" id="spinning_cube_depth_ppline"></a>
Creating the pipeline</h2>
<p>The last piece of initialization is modifying the graphics pipeline create info. What we actually need from the pipeline is to enable depth testing, depth writing and set the depth compare function.</p>
<div class="fragment"><div class="line">VkPipelineDepthStencilStateCreateInfo depthStencil = { VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO };</div><div class="line">depthStencil.depthTestEnable = <span class="keyword">true</span>;</div><div class="line">depthStencil.depthWriteEnable = <span class="keyword">true</span>;</div><div class="line">depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;</div><div class="line">depthStencil.depthBoundsTestEnable = <span class="keyword">false</span>;</div><div class="line">depthStencil.stencilTestEnable = <span class="keyword">false</span>;</div></div><!-- fragment --><p>For this example we chose the most common depth compare operation which is VK_COMPARE_OP_LESS. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">
        <a class="copyright" href="http://www.arm.com/">(C) ARM Ltd. 2016</a>
    </li>
  </ul>
</div>
</body>
</html>
